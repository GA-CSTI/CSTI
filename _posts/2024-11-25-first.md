---
layout: single
title: "chapter 02. OOP와 스프링 프레임워크"
categories: coding
---

### A. 객체지향 프로그래밍(OOP)을 왜 하는가?

1. 소프트웨어(VS 하드웨어)

1) 소프트웨어는 계속 바꾸고 수정할 수 있음

- 예)카카오톡

> 처음에는 단순 메시지 대신으로 쓰임

> 현재는 결제, 쇼핑하기, 게임 등등 다양한 기능들을 제공

### B. 객체지향이란 무엇인가?

**1. 분류: 코드를 적절히 잘 분류할 수 있어야 한다.**

예) 도서관에서 원하는 책을 빨리 찾는 방법

- 분류를 잘 하면 찾기 쉽다.

1) Class의 역할

(1) 프로그램의 코드를 체계적으로 분류

(2) 같은 역할을 하는 코드를 응집성 있게 모아줌

2) 객체지향 프로그래밍(OOP)

(1) 소프트웨어의 복잡성을 해결하고 관리할 수 있는 방법( 가장 대중적이고 좋다고 알려진 방법)

(2) 데이터(상태, 필드)와 로직(행위, 메소드)이 응집되어 상호 교류하며, 동작하도록 만드는 프로그래밍 기법

**2. 교체: 경우에 따라 특정 모듈을 통째로 변경해야 할 수도 있다.**

예) - 시스템의 변경

- Oracle DB → Mysql DB

- RDB → NoSQL

- 문자 발송 외부 업체 변경

1) OOP설계 시 고려할 점

(1) 소프트웨어를 말랑말랑하게(수정이 쉽게) 유지하기 위한 것은 쉽지 않다

(2) 좋지 않은 설계 예시

- 스파게티 면이 꼬여있듯이 기능 추가될때 마다 줄줄이 엮어서 코딩

- if else문의 반복 코딩

2) 변경이 어려운 이유들

(1) 너무 복잡하게 기능이 섞여 있어서 어디를 어떻게 고쳐야 할지 파악이 어렵다.

(2) 기능 추가 후 기존에 잘 돌던 기능들이 갑자기 동작하지 않는다.

(3) 내가 고친 곳과 상관 없는 전혀 엉뚱한 곳이 갑자기 잘못 동작한다.

### C. OOP를 잘하는 방법 SOLID

1. 분류 : 구글과 같이 20억 라인의 긴 코드는 어떻게 관리해야 할까?

2. 교체 : 갑자기 내가 쓰던 라이브러리가 없어진다면?

3. SOLID 원칙

1) SRP : 단일 책인 원칙(분류)

(1) 한 클래스는 단일의 책임만 가져야 한다

2) OCP : 개방 폐쇄 원칙(교체)

(1) 확장에는 열려있고, 변경에는 닫혀있다.

3) LSP : 리스코프 치환 원칙(교체)

(1) 서브타입은 언제나 기본타입으로 교체할수 있어야 한다.

(2) 상속 받은 클래스는 부모 클래스와 동일한 동작을 해야 재활용 가능성이 높아진다.

(부모타입을 인터페이스처럼 생각할 것)

(3) 실무에선 의외로 상속을 많이 사용하지 않는다.

- 상속 시 오버라이드를 한 것과 아닌 것의 혼란

- 상속 오버라이드를 잘못하면 로직 충돌

- 기능을 너무 확장하거나 변경하면 재활용성이 낮아짐

(4) 상속의 대안 또는 상속을 잘하는 방법

- 상속을 위한 설계를 한 클래스만 상속하라

- 부모 클래스 상속 대신 인터페이스를 활용하라

- 피할 수 없다면 상속을 하지만 부모와 상호 치환이 가능하도록 하라

→ 부모 클래스와 동일한 기능 제공

4) ISP : 인터페이스 분리 원칙(분류)

(1) 인터페이스도 단일 책임을 갖도록 분리해야 한다.

(2) SRP와 다소 유사하지만 인터페이스도 단일의 책임을 갖도록 설계해야 필요한 기능만 구현하고 제공할 수 있다.

(3) 너무 큰 인터페이스를 만들면 빈 메서드를 만드는 경우가 발생

5) DIP : 의존성 역전 원칙

(1) 하위 모듈의 변경이 상위 모듈의 변경을 요구하는 의존성을 끊어내야 한다.

→ 개발을 하다 보면 내가 사용하던 라이브러리를 다른 라이브러리로 변경하면 코드를 다 뜯어 고쳐야 하는 경우가 있는데 그렇게 라이브러리에 직접적으로 의존하면 교체가 어렵다.

→ 라이브러리를 너무 의존하지 않도록 하자.

→ 의존성을 역전시키도록 개발(하위 모듈이 상위 모듈에 의존하도록 설계)

4. SOLID Wrap-up

1) SOLID

(1) SRP(분류) : 컨플릭(충돌)을 방지, 역할에 해당하는 서비스를 잘 찾는다.

(2) OCP(교체) : if else 에서 반복적인 케이스가 보이면, 클래스 분리를 고려

(3) LSP(교체) : 상속보다는 IF를 고려하고, 상속을 해도 비슷하게 만들어야 교체가 쉽다.

(4) ISP(분류) : 인터페이스도 OCP를 따라야 구현이 편리하고 재활용성이 올라간다.

(5) DIP(교체) : 하위 모듈에 너무 의존하면 변경이 어려움, 중간 IF를 둬야 하위 모듈 변경이 쉽다.

2) 새로운 어플리케이션에서는 SOLID 원칙을 다 지키기 어렵고 한다고해도 코드만 복잡해 질 수 있다.

3) KISS (Keep It Simple Stupid)

(1) 코딩을 심플하게 해라.

(2) 기획내용을 잘 검토하여, 개발할 때 개발내용이 복잡한 경우, 개발자가 기획자에게 역제안을 하여 복잡도를 낮춘다.

4) YAGNI (You Ain’t Gonna Need It)

(1) 애매한건 지운다(쓰지 않거나, 활용도가 낮은 메서드나, 클래스를 과감하게 지운다)

→ 분석하는 데 필요한 리소스자원을 잡아먹을 수 있음

5) 처음부터 억지로 적용하려고 하지말고, 시스템이 성장하면서 복잡해질때 SOLID를 한번 떠올려본다.

### D. SOLID를 잘하는 방법 스프링

1. 분류(SRP,ISP)

1) Three-Layer 아키텍쳐 in Spring MVC

> 스프링 Web MVC에서 가장 대중적으로 활용되는 역할 분리 방법

a. 표준적인 레이어 별 역할을 나눠주기 때문에 SRP를 도와줌

→ 클래스의 역할이 조금 더 명확해짐

→ 코드의 파악이 더 쉬워짐

* OSI 7 계층과 유사

(1) Presentation layer[표현 레이어] = Controller Classes

(2) Business Logic layer[비즈니스로직 레이어] : Service Classes

(3) Data Access layer[데이터 접근 레이어] : Repository Classes

2. 교체(OCP,LSP,DIP)

1) DI Container - Dependency Injection Container

(1) 개체들을 담아주는 큰 저장소

(2) 의존성 주입 컨테이너(상자)

(3) 스프링의 핵심

2) DI Config

(1) OCP, LSP, DIP의 손쉬운 교체

(2) 코드 상에서는 의존성 없이 DI Config만으로 의존 클래스 변경

3) 꼭 스프링을 써야하는가?

(1) 교체가 자유롭고 단일 책임을 잘 지키도록 분류를 잘해서 짜려면 이렇게 샘플처럼 짜보면 됩니다 = 스프링

(2) SOLID를 지키려고 짜다보면 결국 스프링과 비슷한 기능을 만들게 된다.

→ 굳이 반복적으로 SOLID에 맞게 만들 필요 없이 잘 만들어진 스프링을 쓰면 된다.

→ 하지만 한번쯤 SOLID에 맞게 직접 코드를 짜보면 스프링을 이해하는데 큰 도움이 된다.