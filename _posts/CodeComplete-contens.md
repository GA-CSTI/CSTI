---
title: "cc"
search: false
published: false
---
[1부] 기초 확립
# 1장: 소프트웨어 구현으로의 초대
## 1.1 소프트웨어 구현이란 무엇인가?
## 1.2 소프트웨어 구현이 중요한 이유는 무엇인가?
## 1.3 이 책을 읽는 방법

# 2장: 소프트웨어 개발의 이해를 돕기 위한 비유
## 2.1 비유의 중요성
## 2.2 소프트웨어 비유 사용법
## 2.3 일반적인 소프트웨어 비유

# 3장: 준비는 철저하게: 선행 조건
## 3.1 선행 조건의 중요성
## 3.2 작업 중인 소프트웨어의 종류 결정
## 3.3 문제-정의 선행 조건
## 3.4 요구사항 선행 조건
## 3.5 아키텍처 선행 조건
## 3.6 선행 조건에 소요되는 시간

# 4장: 구현 시 결정해야 할 핵심 사항
## 4.1 프로그래밍 언어 선택
## 4.2 프로그래밍 규약
## 4.3 기술 흐름 파악
## 4.4 구현 실천법 선택

[2부] 고품질 코드 작성
# 5장: 구현 설계
## 5.1 설계의 어려움
## 5.2 핵심 설계 개념
## 5.3 설계 빌딩 블록: 발견적 학습
## 5.4 설계 실천법
## 5.5 잘 알려진 방법론에 대한 의견

# 6장: 클래스 다루기
## 6.1 클래스의 토대: 추상 데이터형(ADT)
## 6.2 좋은 클래스 인터페이스
## 6.3 설계와 구현 문제
## 6.4 클래스를 작성하는 이유
## 6.5 프로그래밍 언어와 관련된 이슈
## 6.6 클래스를 넘어서: 패키지

# 7장: 고급 루틴
## 7.1 루틴을 작성하는 이유
## 7.2 루틴 수준의 설계
## 7.3 좋은 루틴 이름
## 7.4 루틴의 길이에 대한 문제
## 7.5 루틴 매개변수 처리
## 7.6 함수를 사용할 때 특별히 고려해야 할 사항
## 7.7 매크로 루틴과 인라인 루틴

# 8장: 방어적인 프로그래밍
## 8.1 잘못된 입력으로부터 프로그램 보호
## 8.2 어설션
## 8.3 오류 처리 기법
## 8.4 예외
## 8.5 오류로 인한 손상을 막기 위한 방책
## 8.6 디버깅 보조 도구
## 8.7 제품 코드를 얼마나 방어적으로 프로그래밍할 것인지 정하기
## 8.8 방어적인 프로그래밍에 대해서 한 번 더 고민하기

# 9장: 의사코드 프로그래밍 프로세스
## 9.1 클래스 및 루틴 개발 단계 요약
## 9.2 전문가를 위한 의사코드
## 9.3 PPP를 이용한 루틴 구현
## 9.4 PPP 대안

[3부] 변수
# 10장: 변수 사용 시 고려할 사항
## 10.1 데이터 사용 능력
## 10.2 변수 선언을 쉽게 만드는 방법
## 10.3 변수 초기화 가이드라인
## 10.4 범위
## 10.5 지속성
## 10.6 결합 시점
## 10.7 데이터형과 제어 구조 사이의 관계
## 10.8 변수를 한 목적으로만 사용하기

# 11장: 변수 이름의 기능
## 11.1 좋은 이름을 위한 고려 사항
## 11.2 특정 타입의 데이터 이름 짓기
## 11.3 이름 규약의 효과
## 11.4 비형식적인 이름 규약
## 11.5 표준 접두사
## 11.7 피해야 할 변수 이름

# 12장: 기본 데이터형
## 12.1 숫자 일반
## 12.2 정수
## 12.3 부동 소수점 수
## 12.4 문자와 문자열
## 12.5 불린 변수
## 12.6 열거형
## 12.7 이름 상수
## 12.8 배열
## 12.9 새로운 형 만들기(형 별명)

# 13장: 특이한 데이터형
## 13.1 구조체
## 13.2 포인터
## 13.3 전역 데이터

[4부] 명령문
# 14장: 순차적 코드 구성하기
## 14.1 순서가 중요한 명령문
## 14.2 순서가 중요하지 않은 명령문

# 15장: 조건문 사용
## 15.1 if 문
## 15.2 case 문

# 16장: 반복문 제어
## 16.1 반복문 종류 선택
## 16.2 반복문 제어
## 16.3 반복문을 쉽게 작성하는 법 - 안에서부터 밖으로
## 16.4 반복문과 배열의 연관성

# 17장: 특이한 제어 구조
## 17.1 여러 곳에서 반환하는 루틴
## 17.2 재귀문
## 17.3 goto 문
## 17.4 특이한 제어 구조에 대한 관점

# 18장: 테이블 활용 기법
## 18.1 테이블 활용 기법에서 일반적으로 고려해야 할 사항
## 18.2 직접 접근 방식
## 18.3 인덱스 접근 방식
## 18.4 단계적 접근 방식
## 18.5 그 밖의 테이블 참조 방법

# 19장: 제어와 관련된 일반적인 이슈
## 19.1 불린 표현식
## 19.2 복합문(블록)
## 19.3 널 명령문
## 19.4 지나치게 깊은 중첩 구조 처리
## 19.5 프로그래밍의 기초: 구조적 프로그래밍
## 19.6 제어 구조와 복잡성

[5부] 코드 향상
# 20장: 소프트웨어 품질
## 20.1 소프트웨어 품질의 특성
## 20.2 소프트웨어의 품질을 향상시키기 위한 기법들
## 20.3 품질 향상 기법의 상대적 효과성
## 20.4 품질 보증 활동 시기
## 20.5 소프트웨어 품질의 일반적인 원칙

# 21장: 협력 구현
## 21.1 협력 개발 방법 개요
## 21.2 짝 프로그래밍
## 21.3 형식적인 정밀 검토
## 21.4 여러 가지 협력 개발 방법

# 22장: 개발자 테스트
## 22.1 소프트웨어 품질에서 개발자 테스트의 역할
## 22.2 개발자 테스트에 대한 바람직한 접근 방법
## 22.3 여러 가지 교묘한 테스트 방법
## 22.4 전형적인 오류
## 22.5 테스트 지원 도구
## 22.6 테스트를 향상시키는 방법
## 22.7 테스트 기록을 보존하는 방법

# 23장: 디버깅
## 23.1 디버깅 이슈 소개
## 23.2 결함 발견
## 23.3 결함 수정
## 23.4 디버깅에서 심리학적으로 고려해야 할 사항
## 23.5 디버깅 도구 ? 분명한 도구와 그렇지 않은 도구

# 24장: 리팩터링
## 24.1 소프트웨어 진화의 종류
## 24.2 리팩터링 소개
## 24.3 구체적인 리팩터링
## 24.4 안전한 리팩터링 방법
## 24.5 리팩터링 전략

# 25장: 코드 튜닝 전략
## 25.1 성능이란?
## 25.2 코드 튜닝 소개
## 25.3 느리고 비대한 부분
## 25.4 측정
## 25.5 반복
## 25.6 코드 튜닝 단계 요약

# 26장: 코드 튜닝 기법
## 26.1 논리 구조
## 26.2 반복문
## 26.3 데이터 변환
## 26.4 표현식
## 26.5 루틴
## 26.6 저급 언어를 이용한 재구성
## 26.7 변경이 많을수록 상태는 그대로

[6부] 시스템 고려 사항
# 27장: 프로그램의 크기가 구현에 미치는 영향
## 27.1 의사소통과 크기
## 27.2 프로젝트 크기의 범위
## 27.3 프로젝트의 크기가 오류에 미치는 영향
## 27.4 프로젝트의 크기가 생산성에 미치는 영향
## 27.5 프로젝트의 크기가 개발 활동에 미치는 영향

# 28장: 구현 관리
## 28.1 훌륭한 코딩 장려
## 28.2 형상 관리
## 28.3 구현 일정 예측
## 28.4 측정
## 28.5 개발자를 사람으로 대우하기
## 28.6 관리자 관리

# 29장: 통합
## 29.1 통합 접근 방법의 중요성
## 29.2 통합 빈도-단계별 또는 점증적 접근 방법
## 29.3 점증적 통합 전략
## 29.4 일일 빌드와 스모크 테스트

# 30장: 프로그래밍 도구
## 30.1 설계 도구
## 30.2 소스코드 도구
## 30.3 실행 코드 도구
## 30.4 도구 지향적인 환경
## 30.5 자신만의 프로그래밍 도구 개발
## 30.6 프로그래밍 도구에 대한 환상

[7부] 소프트웨어 장인정신
# 31장: 레이아웃과 스타일
## 31.1 레이아웃 기초 지식
## 31.2 레이아웃 기법
## 31.3 레이아웃 스타일
## 31.4 제어 구조의 레이아웃
## 31.5 개별 명령문 레이아웃
## 31.6 주석 레이아웃
## 31.7 루틴 레이아웃
## 31.8 클래스 레이아웃
참고 서적

# 32장: 스스로를 설명하는 코드
## 32.1 외부 문서
## 32.2 문서화를 위한 프로그래밍 스타일
## 32.3 주석을 작성할 것인가? 작성하지 않을 것인가?
## 32.4 효과적인 주석을 위한 핵심 사항
## 32.5 주석 스타일
## 32.6 IEEE 표준

# 33장: 개발자의 성격
## 33.1 성격은 주제를 벗어난 것 아닌가?
## 33.2 지성과 겸손
## 33.3 호기심
## 33.4 지적인 정직함
## 33.5 의사소통과 협동
## 33.6 창의성과 훈련
## 33.7 게으름
## 33.8 덜 중요한 특성
## 33.9 습관

# 34장: 소프트웨어 장인정신에 대한 주제
## 34.1 복잡성 정복
## 34.2 자신에게 맞는 프로세스 선택
## 34.3 컴퓨터보다 사람을 위한 프로그램을 작성하라
## 34.4 언어에 제약을 받지 않고 언어를 활용한 프로그래밍
## 34.5 규약을 활용하여 핵심에 집중
## 34.6 문제 중심의 프로그래밍
## 34.7 낙석을 주의하라
## 34.8 반복, 반복, 또 반복
## 34.9 소프트웨어와 신조를 떼어 놓아라

# 35장: 더 많은 정보를 얻으려면
## 35.1 소프트웨어 구현에 관한 정보
## 35.2 구현 외의 주제
## 35.3 정기 간행물
## 35.4 소프트웨어 개발자의 독서 계획
## 35.5 전문가 협회에 가입