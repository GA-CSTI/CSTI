---
title:  "[Code Complete 2] 3부 - 변수"
search: true
categories: 
  - 독서
tags:
  - CodeComplete2
classes: wide
---

[3부] 변수

# 10장: 변수 사용 시 고려할 사항
## 10.1 데이터 사용 능력
- N/A
## 10.2 변수 선언을 쉽게 만드는 방법
- N/A
## 10.3 변수 초기화 가이드라인
- 포인터 초기화는 nullptr
- 데이터 초기화는 0xDEADBEEF 또는 0xCC - 데이터영역에서 실행 시 breakpoint. 근데 NX때문에 이게 안될텐데 ?
## 10.4 범위
- 범위가 커지면 코드짜기는 쉽지만 이해는 어려워진다.
- 변수의 수명과 사용범위를 최대한 짧게 유지해라. 정의와 사용은 가깝게. protected보다는 private를. 전역은 최후의 수단이어야 한다.
- 범위를 최소화하는 건 정보 은닉과도 관계가 있다.
## 10.5 지속성
- N/A
## 10.6 바인딩 시간 * 중요
- 바인딩 시간이 이를수록 코드는 단순해지지만, 더 strict 해진다(바인딩 타임 : 코드작성 - 컴파일 - 로드 - 객체생성 - JIT).
- 복잡성을 최소화시키는 것이 중요하지만 유연성과의 tradeoff 를 고려해서 줄을 잘 타자.
## 10.7 데이터형과 제어 구조 사이의 관계
- N/A
## 10.8 변수를 한 목적으로만 사용하기 * 중요
- 말 그대로다.

# 11장: 변수 이름의 기능
## 11.1 좋은 이름을 위한 고려 사항
- 가능한 한 구체적으로. 'how' 보다는 'what' 을 표현하라.
- 길이는 8-20자 사이, 세 단어 조합 이내.
- 전역변수 써야 한다면 네임스페이스로 나눌 수는 없는지 고려하기. 
## 11.2 특정 타입의 데이터 이름 짓기
- status flag 는 상수로 정의하고 사용하기. (bad: if status == 0x80)
- boolean 은 참/거짓을 나타내는 단어로. is 를 붙이면 의문문이 되니까 주의. (bad : if (isFound) / good: if (found))
## 11.3 이름 규약의 효과
- 규약의 효과는 어떤 규약을 선택하느냐가 아니라 규약이 존재한다는 사실로부터 온다.
- 규약이 없으면 동일한 것을 다른 이름으로 부르기 쉽다. 경험상 이게 참 고역이다.
## 11.4 비형식적인 이름 규약
- 책에서는 변수/객체 이름은 소문자로 시작하고 함수 이름은 대문자로 시작한다.
- 타입과 변수명은 변수명을 좀 더 구체적으로 작성함으로써 구분한다. 그게 이해하기가 쉽기 때문.
## 11.5 표준 접두사
- min, max, first, last, ...
## 11.6 읽기 쉬운 짧은 이름
- 축약에 대한 내용. 모음 빼고 뭐 그런건데 굳이 축약 안 해야겠다.
## 11.7 피해야 할 변수 이름
- 숫자 포함하지 말것. 읽기 어려운 단어 사용하지 말 것.


# 12장: 기본 데이터형
## 12.1 숫자 일반
- 매직 넘버 대신 named constant 를 써보자.
## 12.2 정수
- 나누기 형변환 주의. (int / int = int)
- 정수 오버플로우 주의. (int + int = int)
## 12.3 부동 소수점 수
- 라운딩 오차 주의. (0.1 + 0.2 = 0.30000000000000004)
## 12.4 문자와 문자열
- 리터럴 문자열은 상수로 선언하고 사용하기. ("hello" -> const char* hello = "hello")
- 다중언어를 지원해야 한다면 유니코드를 사용하자.
- off by one 이나 null-terminated 를 각별히 신경쓰기.
## 12.5 불린 변수
- N/A
## 12.6 열거형
- 불린보다 더 유연하게 사용할 수 있다. 불린을 대체할 방법 중 하나.
## 12.7 이름 상수
- 최대한 쓰자 유용하니까
## 12.8 배열
- N/A
## 12.9 새로운 형 만들기(형 별명)
- typedef 를 활용하기. 정보 은닉에도 좋고, 수정도 용이해짐. 읽기도 좋아진다.
- typedef 하기 전에 혹시 새로운 클래스를 만들어야 하진 않는지 생각하기.

# 13장: 특이한 데이터형
## 13.1 구조체
- 클래스를 쓰고 싶겠지만 구조체가 유용할 때도 있다.
## 13.2 포인터
- 같은 영역 내에서 할당과 삭제하기. 적어도 Scope 와 Pair 를 생각하기.
- 포인터는 nullptr 을 가리킬 수 있고, 레퍼런스는 항상 객체를 참조해야 하며 초기화 후에는 변경이 불가하다는 차이가 있다.
## 13.3 전역 데이터
- 일반적인 용도로는 일단 안 쓰는 것이 좋다. 동시성 문제, 초기화 순서 문제, 모듈화를 어렵게 하는 문제 등.
- named constant, 데이터 테이블(레지스트리) 등의 용도로는 유용하다. 
- 접근 루틴(싱글턴 같은)을 활용하는 것이 더 좋다. 추상화도 쉬워진다.