---
layout: single
title: "게임프로그래밍"
---

# 2024학년도 2학기

게임 프로그래밍


- Viewport : 현재 level의 콘텐츠를 보여주며, 레벨 내에서 탐색하고, 객체를 추가, 이동 제거 및 편집
  - 레벨을 시각화 하고 그안에 객체를 조작할 수 있게 해준다.
  - UE5에서는 level이 객체의 모음과 그들의 위치 및 속성을 나타냄
  - 항상 현재 선택된 레벨의 콘테느를 보여준다.
  - 여러개의 level을 생성하고 Content Browser 창을 통해 전환 가능
  - 그리드의 스냅 옵션을 통해 변경 가능
- Outliner : 레벨에 있는 객체들을 빠륵 나열하고 조작
- Details : level에서 선택한 객체의 속성을 편집할 수 있다.
- Toolbar : 현재의 level을 저장, 객체 추가, 재생등의 작업 수행
- Content Drawer

Blueprint : UE5의 visual scriting 언어

C++과 Blueprint의 차이점
- C++ class에 프로그래밍 로직을 추가하면 Blueprint class 를 만들때보다 더 고급엔진 기능에 접근 가능
- Blueprint class에서 해당 클래스의 비쥬얼 구성 요소를 쉽게 보고 수정 가능,  C++ 클래스에서 정의된 속성도 수정 가능
- Blueprint class에서는 프로젝트의다른 에셋을 쉽게 참조 할 수 있지만 C++은 덜 간단하고 덜 유연하다
- C++ class는 동시에 작업(소스 버전 관리 플랫폼에 충돌 없이 간단함)이 가능하지만 Blueprint class는 협업을 할때 깃 같은 곳에 파일을 올리면 텍스트 파일이 아닌 binary화 되어 오류 발생
- Blueprint class는 C++, 다른 Blueprint 상속 가능
- C++에 프로그래밍 로직 작성 후 그 클래스를 상속받는 블루프린트 클래스를 만들 수 있으며, C++에서 정의한 속성과 메소드 접근 지정 가능, 속성 편집 뿐 아니라 Blueprint script 언어를 사용하여 함수 호출, 오바라이드도 가능



Blueprint Editor
1. Viewport : Level Viewport와 유사하게 Actor를 시각화 하고 구성요소를 편집할 수 있게 해준다.
   - 3가지 : Viewport / Construction Scripts / Event Graph
   - Event Graph : 모든 Blueprint visual scripting code르 작성하고, 변수와 함수를 생성하여 부모 클래스에서 선언된 다른 변수와 함수에 접근
                    
2. Components : Blueprint class 에서 여러 Actor 구성요소를 추가하고 제거 가능, 상속 받은 C++ class에서 정의된 Actor 구성요소에 접근할 수 있게 해준다.
3.  My Blueprint : Blueprint 와 C++ class에서 정의된 변수와 함수를 탐색, 추가 및 제거
4. Details : 현재 선택된 Actor의 구성요소, 함수, 변수, 이벤트 or 이 Blueprint 클래스의 다른 개별 요소의 속성 보여줌
5. Toolbar : Blueprint class에서 작성한 코드를 컴파일 하고 저장하며, Content Browser창에서 위치를 찾고 이 클래스에 접근하는 등의 작업 수행 가능


대부분의 Blueprint는 새로운 Actor를 만드는데 사용

UE5는 이벤트를 사용하여 Actor의 상태를 알린다.

event와 actor는 Event Graph 패널에서 노드로 표현


ThirdPersonCharacter Blueprint class
- Actor 내부에 존재해야 하는 엔티티(객체)로, Actor의 로직을 여러 다른 Actor 컴포넌트로 분산시킬 수 있게 해준다.
- 일부 Actor 컴포넌트는 시작적 표현이 없으며, 순수하게 C++ or Blueprint 코드로 구성
- 로직은 Blueprint가 아니라 C++ 클래스에서 정의된다.


컴퓨터가 3D객체를 시작적으로 표현하기 위해서는 두가지가 필요
UE5에서 메쉬 컴포넌트를 통해 매쉬 추가 가능, 메쉬 컴포넌트는 Actor COmponent를 상속
Mesh 
1.  3D meshes : 객체의 형태와 크기를 지정
      - 객체의 크기, 형태 지정, 여러 개의 정점, 모소리, 면으로 구성
      - 각 면은 빛의 반사에 따라 흰 ~ 검 까지의 색상으로 표현

2.  Material : 객체의 색상과 시작적 톤을 비롯한 다양한 특성을 지정
      - 메쉬가 어떻게 표현될지를 지정
      - 메쉬의 색상을지정, 표면에 텍스처 그리기, 정점 조작


객체 지향 프로그래밍 ( Objec Oriented Programming )
- Blueprint는 부모를 하나 밖에 못가짐
- 객체를 생성하고 상태(변수 or 속성)의 초기값을 제공하며 행동(event or func)의 구현을 위한 템플릿
- 캡슐화 : 다른 클래스의 관점에서 클래스의 복잡성을 숨길수 있게 해준다.
- Instanes (객체) : 클래스에서 생성된 객체의 해당클래스에 인스턴스이다. 
                              모든 인스턴스는 Blueprint에서 정의된 것과 동일 한 변수 생성
                              각 인스턴스의 값은 level에서 변경 가능 하며 다른 인스턴스에 영향을 주지 않는다.
- 상속 (Inheritance) : 부모는 하나, 자식은 여러개, 오버라이드(재정의) 가능
- Actor 클래스는 level에 배치되거나 생성 될 수 있는 모든 객체의 부모 클래스


Hierarchy of Common Classes
Pawn : Actor의 자식 클래스, 게임에서 컨트롤러에 의해 소유될 수 있는 엑터
Charctor : Pawn의 자식 클래스, Charactor클래스는 Controller 클래스에 의해 소유 될수 있다.,
PlayerController : 인간 플레이어가 사용 
AIOntroller : AI를 이용하여 Pawn을 제어
Pawn 및 Character 클래스의 인스턴스는 PlayerController 인스턴스가 이들을 소유하고 있을때만 입력 이벤트를 받을 수 있다.
GameModeBase : GameMode를 생성하기 위한 부모 클래스, 게임의 규칙을 정하고 (Pawn, PlayerController, GameStateBase, HUD, other classes) 의 기본 클래스를 지정하는데 사용

각 level은 서로 다른 GameMode를 가질 수 있다.
레벨에 GameMode는 프로젝트의 기본 GameMode를 덮어 쓴다.
Game Instance : GameInstane 클래스와 그 데이터는 level간에 지속 된다.



========================================================
Solution Analysis : 프로젝트 디렉토리 내에서 생성된 비쥬얼 스튜디오 솔루션(.sln) 파일은 저네 프로젝트와 추가된 모든 관련 코드를 포함한다, 솔루션 탐색기에서 Engine과 Games라는 두 개의 프로젝트를 볼 수 있다.

The Engine Project : 기본적으로 언리얼 엔진 자체가 비쥬얼 스튜디오 프로젝트이며, 솔루션 파일을 가지고 있다.
언리얼 엔진을 써서 이 프로제트 내의 모든 코드를 소스 코드라고 한다.

config 폴더 : 프로젝트와 빌드를 위해 설정된 모든 구성 파일을 포함
plugins 폴더 : 타사 Plugin을 추가할 떄 생성되는 선택적 폴더
Source 폴더 : 작업할 주요 폴더, BuildTarget과 프로젝트의 모든 소스코드가 포함
게임을 빌드하는 사용할 Unreal build tool을 지정하는 코드 포함
ProjectName code filed : 기본적으로 각 프로젝트마다 생성, 기본 게임 모듈 코드를 실행하는데 사용되는 코드를 포함
ProjectNmaeGameModeBase code fies : 기본적으로 빈 프로젝트 GameModeBase가 생성

사용자가 다양한 파일 유형을 가져와 project를 사용자 정의 할 수 있도록 허용


Unreal Game Mode class
플레이어가 게이멩 들어 올때 게임흐름을 처리하는 역할
게임 흐름은 게임내에서 발생하는 모든 행동이나 일련의 행동일 수 있따.
Game Mode는 게임 논리를 구동하고 Player()에 게임 관련 규칙을 부과하는 클래스
모든 관리자를 포함하고 있으며, 싱글톤 클래스로, 게임에 존재하는 어떤 객체나 추상 클래스에서도 접근할 수 이싿.

GameMOde는 다음과 같은 기본 클래스를 지정 가능 : 로그인 승인, 게임 상태 처리, Pawn 을 소유하고 제어, 게임내에서 현재상태를 등등 
이러한 클래스들은 GameMode와 함꼐 작동, 별도로 월드에 배치X해도 자동으로 실행
GamemOde는 여러 이벤트를 제공하여 멀티플레이어 게임 로직을 처리할수 있도록 한다.
네트워크 게임일떄 : 클라이언트나 참여한 플레이어에게 GameModeclass를 복제하지 않는다.
GamePlaylogic은 클라이언트에 존재해서x, 서버에만 존재해야 한다.
AGameModeBase는 모든 GameMode클래스의 부모역활을 한다.
기본적으로 GameModeBase는 새 템플릿 기바느 프로젝트에 포함되며,ㅡ 더 복잡한 게임 플레이 로직을 필요로 허지 않는 프로젝트에 적합상태머신을 포함하여, 플레이어의 상태를 처리하고 추적ㅎ는데 중점, 이를 통해 게임의 흐름과 규칙을 보다 세밀하게 제어 가능
Level은 게임의 일부분을 나타내며 클 규모의 게임은 여러개의 LEvel로 나눠짐
GameMode는 특정레벨에 직접 적용될 수 있으며 레벨을 로드할때, 해당 레벨에 할당된 Gamemode클래스가 그 레벨의 모든 로직과 게임 플레이를 처리
LevelBlueprint는 해당 레벨 내에서 실행, 레벨 범위를 벗어나서는 접근x
GameMode는 GetGameMode노드로 모든 Bluepritn에 접근 가능


Working with animations
ANimation Blueprint는 두가지 그래프를 제공
1. Event graph : 애니메이션과 관련된 논리적 흐름을 관리하는 그래프, 캐릭터의 상태에 따라 애니메이션을 트리거하거나 멈출수 있다
2. ANuimGraph : 실제 애니메이션을 구성하는 그래프, 캐릭터 움직임 정의 달리기 점프등의 동작 설정
애니메이션과 관련된 설정 이벤트를 제공 주로 Animaion Bluepritn 내에서 사용 ㅌ
