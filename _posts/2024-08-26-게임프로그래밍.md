---
layout: single
title: "게임프로그래밍"
---

# 2024학년도 2학기

게임 프로그래밍


- Viewport : 현재 level의 콘텐츠를 보여주며, 레벨 내에서 탐색하고, 객체를 추가, 이동 제거 및 편집
  - 레벨을 시각화 하고 그안에 객체를 조작할 수 있게 해준다.
  - UE5에서는 level이 객체의 모음과 그들의 위치 및 속성을 나타냄
  - 항상 현재 선택된 레벨의 콘테느를 보여준다.
  - 여러개의 level을 생성하고 Content Browser 창을 통해 전환 가능
  - 그리드의 스냅 옵션을 통해 변경 가능
- Outliner : 레벨에 있는 객체들을 빠륵 나열하고 조작
- Details : level에서 선택한 객체의 속성을 편집할 수 있다.
- Toolbar : 현재의 level을 저장, 객체 추가, 재생등의 작업 수행
- Content Drawer

Blueprint : UE5의 visual scriting 언어

C++과 Blueprint의 차이점
- C++ class에 프로그래밍 로직을 추가하면 Blueprint class 를 만들때보다 더 고급엔진 기능에 접근 가능
- Blueprint class에서 해당 클래스의 비쥬얼 구성 요소를 쉽게 보고 수정 가능,  C++ 클래스에서 정의된 속성도 수정 가능
- Blueprint class에서는 프로젝트의다른 에셋을 쉽게 참조 할 수 있지만 C++은 덜 간단하고 덜 유연하다
- C++ class는 동시에 작업(소스 버전 관리 플랫폼에 충돌 없이 간단함)이 가능하지만 Blueprint class는 협업을 할때 깃 같은 곳에 파일을 올리면 텍스트 파일이 아닌 binary화 되어 오류 발생
- Blueprint class는 C++, 다른 Blueprint 상속 가능
- C++에 프로그래밍 로직 작성 후 그 클래스를 상속받는 블루프린트 클래스를 만들 수 있으며, C++에서 정의한 속성과 메소드 접근 지정 가능, 속성 편집 뿐 아니라 Blueprint script 언어를 사용하여 함수 호출, 오바라이드도 가능



Blueprint Editor
1. Viewport : Level Viewport와 유사하게 Actor를 시각화 하고 구성요소를 편집할 수 있게 해준다.
   - 3가지 : Viewport / Construction Scripts / Event Graph
   - Event Graph : 모든 Blueprint visual scripting code르 작성하고, 변수와 함수를 생성하여 부모 클래스에서 선언된 다른 변수와 함수에 접근
                    
2. Components : Blueprint class 에서 여러 Actor 구성요소를 추가하고 제거 가능, 상속 받은 C++ class에서 정의된 Actor 구성요소에 접근할 수 있게 해준다.
3.  My Blueprint : Blueprint 와 C++ class에서 정의된 변수와 함수를 탐색, 추가 및 제거
4. Details : 현재 선택된 Actor의 구성요소, 함수, 변수, 이벤트 or 이 Blueprint 클래스의 다른 개별 요소의 속성 보여줌
5. Toolbar : Blueprint class에서 작성한 코드를 컴파일 하고 저장하며, Content Browser창에서 위치를 찾고 이 클래스에 접근하는 등의 작업 수행 가능


대부분의 Blueprint는 새로운 Actor를 만드는데 사용

UE5는 이벤트를 사용하여 Actor의 상태를 알린다.

event와 actor는 Event Graph 패널에서 노드로 표현


ThirdPersonCharacter Blueprint class
- Actor 내부에 존재해야 하는 엔티티(객체)로, Actor의 로직을 여러 다른 Actor 컴포넌트로 분산시킬 수 있게 해준다.
- 일부 Actor 컴포넌트는 시작적 표현이 없으며, 순수하게 C++ or Blueprint 코드로 구성
- 로직은 Blueprint가 아니라 C++ 클래스에서 정의된다.


컴퓨터가 3D객체를 시작적으로 표현하기 위해서는 두가지가 필요
UE5에서 메쉬 컴포넌트를 통해 매쉬 추가 가능, 메쉬 컴포넌트는 Actor COmponent를 상속
Mesh 
1.  3D meshes : 객체의 형태와 크기를 지정
      - 객체의 크기, 형태 지정, 여러 개의 정점, 모소리, 면으로 구성
      - 각 면은 빛의 반사에 따라 흰 ~ 검 까지의 색상으로 표현

2.  Material : 객체의 색상과 시작적 톤을 비롯한 다양한 특성을 지정
      - 메쉬가 어떻게 표현될지를 지정
      - 메쉬의 색상을지정, 표면에 텍스처 그리기, 정점 조작


객체 지향 프로그래밍 ( Objec Oriented Programming )
- Blueprint는 부모를 하나 밖에 못가짐
- 객체를 생성하고 상태(변수 or 속성)의 초기값을 제공하며 행동(event or func)의 구현을 위한 템플릿
- 캡슐화 : 다른 클래스의 관점에서 클래스의 복잡성을 숨길수 있게 해준다.
- Instanes (객체) : 클래스에서 생성된 객체의 해당클래스에 인스턴스이다. 
                              모든 인스턴스는 Blueprint에서 정의된 것과 동일 한 변수 생성
                              각 인스턴스의 값은 level에서 변경 가능 하며 다른 인스턴스에 영향을 주지 않는다.
- 상속 (Inheritance) : 부모는 하나, 자식은 여러개, 오버라이드(재정의) 가능
- Actor 클래스는 level에 배치되거나 생성 될 수 있는 모든 객체의 부모 클래스


Hierarchy of Common Classes

Pawn : Actor의 자식 클래스, 게임에서 컨트롤러에 의해 소유될 수 있는 엑터

Charctor : Pawn의 자식 클래스, Charactor클래스는 Controller 클래스에 의해 소유 될수 있다.,

PlayerController : 인간 플레이어가 사용 

AIOntroller : AI를 이용하여 Pawn을 제어

Pawn 및 Character 클래스의 인스턴스는 PlayerController 인스턴스가 이들을 소유하고 있을때만 입력 이벤트를 받을 수 있다.

GameModeBase : GameMode를 생성하기 위한 부모 클래스, 게임의 규칙을 정하고 (Pawn, PlayerController, GameStateBase, HUD, other classes) 의 기본 클래스를 지정하는데 사용

각 level은 서로 다른 GameMode를 가질 수 있다.

레벨에 GameMode는 프로젝트의 기본 GameMode를 덮어 쓴다.

Game Instance : GameInstane 클래스와 그 데이터는 level간에 지속 된다.



========================================================
Solution Analysis : 프로젝트 디렉토리 내에서 생성된 비쥬얼 스튜디오 솔루션(.sln) 파일은 저네 프로젝트와 추가된 모든 관련 코드를 포함한다, 솔루션 탐색기에서 Engine과 Games라는 두 개의 프로젝트를 볼 수 있다.

The Engine Project : 기본적으로 언리얼 엔진 자체가 비쥬얼 스튜디오 프로젝트이며, 솔루션 파일을 가지고 있다.
언리얼 엔진을 써서 이 프로제트 내의 모든 코드를 소스 코드라고 한다.

- config 폴더 : 프로젝트와 빌드를 위해 설정된 모든 구성 파일을 포함
- plugins 폴더 : 타사 Plugin을 추가할 떄 생성되는 선택적 폴더
- Source 폴더 : 작업할 주요 폴더, BuildTarget과 프로젝트의 모든 소스코드가 포함
- 게임을 빌드하는 사용할 Unreal build tool을 지정하는 코드 포함
- ProjectName code filed : 기본적으로 각 프로젝트마다 생성, 기본 게임 모듈 코드를 실행하는데 사용되는 코드를 포함
- ProjectNmaeGameModeBase code fies : 기본적으로 빈 프로젝트 GameModeBase가 생성

사용자가 다양한 파일 유형을 가져와 project를 사용자 정의 할 수 있도록 허용


Unreal Game Mode class

- 플레이어가 게이멩 들어 올때 게임흐름을 처리하는 역할
- 게임 흐름은 게임내에서 발생하는 모든 행동이나 일련의 행동일 수 있따.
- Game Mode는 게임 논리를 구동하고 Player()에 게임 관련 규칙을 부과하는 클래스
- 모든 관리자를 포함하고 있으며, 싱글톤 클래스로, 게임에 존재하는 어떤 객체나 추상 클래스에서도 접근할 수 있다.

GameMOde는 다음과 같은 기본 클래스를 지정 가능 : 로그인 승인, 게임 상태 처리, Pawn 을 소유하고 제어, 게임내에서 현재상태를 등등 

이러한 클래스들은 GameMode와 함꼐 작동, 별도로 월드에 배치X해도 자동으로 실행

GamemOde는 여러 이벤트를 제공하여 멀티플레이어 게임 로직을 처리할수 있도록 한다.

네트워크 게임일떄 : 클라이언트나 참여한 플레이어에게 GameModeclass를 복제하지 않는다.

GamePlaylogic은 클라이언트에 존재해서x, 서버에만 존재해야 한다.

AGameModeBase는 모든 GameMode클래스의 부모역활을 한다.

기본적으로 GameModeBase는 새 템플릿 기바느 프로젝트에 포함되며,ㅡ 더 복잡한 게임 플레이 로직을 필요로 허지 않는 프로젝트에 적합상태머신을 포함하여, 플레이
어의 상태를 처리하고 추적ㅎ는데 중점, 이를 통해 게임의 흐름과 규칙을 보다 세밀하게 제어 가능

Level은 게임의 일부분을 나타내며 클 규모의 게임은 여러개의 LEvel로 나눠짐

GameMode는 특정레벨에 직접 적용될 수 있으며 레벨을 로드할때, 해당 레벨에 할당된 Gamemode클래스가 그 레벨의 모든 로직과 게임 플레이를 처리

LevelBlueprint는 해당 레벨 내에서 실행, 레벨 범위를 벗어나서는 접근x

GameMode는 GetGameMode노드로 모든 Bluepritn에 접근 가능


Working with animations

ANimation Blueprint는 두가지 그래프를 제공
1. Event graph : 애니메이션과 관련된 논리적 흐름을 관리하는 그래프, 캐릭터의 상태에 따라 애니메이션을 트리거하거나 멈출수 있다
2. ANuimGraph : 실제 애니메이션을 구성하는 그래프, 캐릭터 움직임 정의 달리기 점프등의 동작 설정
3. 애니메이션과 관련된 설정 이벤트를 제공 주로 Animaion Bluepritn 내에서 사용








==========================================================================

충돌의 정의 : 두 개의객체가 서로 접촉하는 지점
Line Traces( 선 추적 ) : 게임에서 두 지점 사이에 무언가 있는지 확인하는 방법
주요 기능
1. 게임 월드 내에서 두 지점을 지정
2. 지정된 두 지점 사이에 ray를 쏘아 경로에 있는 객체를 탐지
3. 탐지된 결과를 반환

이용 사례
1. 무기 발사 충돌 감지 : 발사체가 어떤 객체에 맞았는지를 확인한다.
2. 자동 카메라 회전 : 플레이어가 코너를 돌아갈 때, 카메라가 캐릭터를 따라 자동으로 회전하도록 만든다.

Trace Channels
- 특정 유형의객체만 탐지하도록 필터링하는 기능
- 불필요한 충돌 체크를 방지하여 성능을 최적화 한다.
- 특정 시나리오에서 탐지 대상 객체를 제한해 보다 정교한 기능을 구현


Sweep Trace
- Line Trace와 비슷하지만, 단순한 선을 따라 광선을 쏘는 대신, 가상의 shape(모양)을 직선 경로로 던지는 시뮬레이션을 수행, 이를 통해 충돌이나 접촉이 발생하는 첫 번째 지점을 확인할 수 있다.
- 특정 유형의 객체만 감지하도록 설정하는 기능 ex) Object1은 Sweep Trace가 무시(Ignore)하도록 설정되어 감지x, Object2는 Sweep Treae가 Block or Overlap하도록 설정되어 감지 된다.
사용 예시 
1. 캐릭터 충돌 감지 : 공간을 이동하면서 충돌이 발생할 가능성이 있는 지점을 미리 확인
2. 물리적 효과 시뮬레이션 : 가상의 구체나 박스를 던졌을 떄, 무엇과 충돌하는지 확인
3. 복잡한 충돌 처리 : 단순 라인 대신 모양을 사용하여 복잡한 충돌 영역을 탐지


Single Line Trace 
- 단일 객체만 확인
- Block 응답을 가지는 객체를 만나면 추적을 멈춤
- Ignore or Overlap으로 설정된 객체는 무시
- ex) 총알이 날아가다가 첫 번째 벽이나 적과 충돌했을 때 멈추는 경우 사용
- LineTraceSingleByChannel : 가장 처음 충돌한 객체 하나만 감지, FHitResult를 반환

Multi Line Trace
- 동일한 Line Trace로 여러 객체를 확인
- Block 응답을 가지는 객체를 만나면 추적을 멈춤
- 경로 상에 충돌한 모든 Overlap 객체 정보를 반환
- ex) 레이저와 같은 효과로 여러 객체를 감지하거나, 투명한 객체를 통해 뒤에 있는 객체까지 확인하는 경우
- LineTraceMultiByChannel : 충돌한모든객체를 감지 FHitResult객체를저장하는 TArray<FHitResult>를 반환

Line Trace가 눈 근처에서 시작하도록 만들기
1. EnemyCharacter C++ 클래스에서 SightSource라는 새로운 SceneComponent를 선언
2. EnemyCharacter 생성자에서 CreateDefaultSubobject 함수를 사용하여 이 컴포넌트를 생성하고 RootComponent에 붙임
3. CanSeeActor 함수에서 Line Trace의 시작 위치를 Actor의 위치 대신 SightSource 컴포넌트의 위치로 변경
4. BP_EnemyCharacter Blueprint클래스에서 SightSource 컴포넌트의 위치를 적의 머리 위치인 (10, 0 80,)으로 변경







Meshes 
- Static Meshes (정적 메쉬) - 변형 없이 고정된 상태
- Skeletal Meshes - 뼈대를 가지고 애니메이션 가능
- Procedural Meshes - 런 타임에서 동적으로 생성되는 매쉬(자동으로생성)


Spawning :  게임이 실행 중일 때 특정 액터를 게임 세계에 배치하는 작업을 의미


Blueprint Function Libraries : 프로젝트에서 특정 액터와 관련된 일반적인 기능을 분리하여 관리, 재사용성 향상
Actor Components : 여러 액터 클래스에서 사용하는 일부로직을 Actor Component로 이동, 코드 중복 제거, 캡슐화로 다른프로젝트에 재사용 가능

Loose coupling :  모듈간의 의존성을 줄이는 설계 원칙, 부모가 형태만 선언하고 및에서 생성
Interfaces :  액터 간의 공통된 상호작용을 정의하여 구조화 및 조직화에 도움

BlueprintFunctionLibrary : 프로젝트 전반에서 재사용할 수있는 정적 함수들의 집합

Actor components
- 액터는 여러 개의 액터컴포넌트를 가질수 있습니다.
- 액터 컴포넌트는 액터에 추가할 수 있는 객체로, 여러가지 기능을 가질 수 있습니다.
- ex) 캐릭터의 인벤토리를 관리하거나 캐릭터가 날 수 있도록 하는 기능
- 액터 컴포넌트는 항상 액터에 속해야하며 이를 Owner라고 부른다.
- 액터에 로직을 추가하는 두 가지 주요 방법 : 액터 클래스 내에 직접 추가, 액터 컴포넌트를 통해 추가
- Loose coupling ( 굳이 나누는 이유)
    - 가능하다면 액터 클래스 내에 직접 로직을 추가하는 대신 액터 컴포넌트를 사용하는 것이 좋다.
    - player와 enemy 둘다 '체력' 존재 1. 체력 로직을기본 클랙스 구현하고 상속받을 수 있도록 한다.
                                                            2.체력 로직을 액터 컴포넌트에 구현하고 각각 컴포넌트를 추가 


인터페이스는 객체가 구현해야 하는 함수 모음을 포함하는 클래스
- 본질적으로 인터페이스는 객체가 서명하는 계약과 같아서, 그 객체는 해당 인터페이스에 정의된 모든 함수를 구현한다고 선언하는것과 같다. 그런 다음 특정 객체가 해당 인터페이스를 구현하는지 확인하고, 그 인터페이스에 정의된 함수의 구현을 호출 할 수 있다.
-BlueprintNativeEvent : C++에서 선언된 이벤트로, 기본 동작을 가질 수 있지만, 블루프린트에서 오버라이드 할 수 있는 이벤트


1. Blueprint Function Libraries
정의:
프로젝트에서 특정 액터와 관련된 일반적인 기능을 분리하여 재사용성을 높이고 유지보수를 용이하게 만드는 정적 함수 집합.
장점:
코드 중복 제거: 여러 블루프린트에서 동일한 로직을 공유 가능.
전역 함수처럼 사용할 수 있어, 복잡한 계산이나 유틸리티  기능 구현에 적합.
예시:
거리 계산, 벡터 변환, 공통 데이터 처리 등을 함수로 구현하여 전체 프로젝트에서 호출 가능.


=========================================

GameModeBase : 가장 기본이 되는 클래스

GameMode : 네트워크 관련 기능을 더 많이 담당하는 클래스

74p.
LineTrace가 단이 물체를 검출할지 다중 물체를 검출할지에 따라 사용되는 함수 이름

LineTraeSingleByXXX : 단일 충돌 물체 검출 - 처음 충돌된 객체반환

LineTraeMultiByXXX: 다중 충돌 물체 검출 - 충돌한 모든 무레 반환

충돌하고 싶은 무체 필터링 가능

Channel : 오브젝트 Collision의 Trae 채널 - 프로젝트 세팅 창에서 설정

ObjectType : 오브젝트 Collision의 Object 채널 - 프로젝트 세팅 창에서 설정

Profile : 오브젝트 Collision의 Preset - 프로젝트 세팅 창에서 설정

눈에 보이지 않는 총알을 구현할때 LineTrace를 사용하면 편림함

133p.

FSM(유한 상태 기계)
- 유한한 개수의 상태를 가질수 있는 오타마타 즉 '추상기계'
- 적 FSM클래스 생성 -> AEnemy 클래스에 컴포넌트로 붙어, 자신의 역활을수행

Actor 컴포넌트 vs Scene 컴포넌트
- Scene 컴포넌트는 Actor 컴포넌트를 상속 받아 Transform 정보까지 가질수 있도록구현되어 있음
- Scene 컴포넌트는 컴포넌트으 위치, 회전, 크기 정보를 변경할수 있음


AnimInstance 

스켈레탈메시의 애니메이션을 제어하는 사용되는 클래스

특정 캐릭터의 애니메이션 블루프린트를 관리하며, 애니메이션 상태, 변수, 함수 등을 활용하여 캐릭터의 동작을 동적으로 업데이트합니다.

몽타주

따로 촬영된 화면을 떼어 붙이면서 새로운 장면이나 내용을 만드는 기법. 영화 편집에서 몽타주는 일련의 짧은 샷들을 제약된공간, 시간, 정보에연속하게 편집하는 테크닉

애니메이션 모앝주는 크게 섹션과 노티파이 기능으로 나누어 볼 수 있음

어떤 상태에서도 transition이 발생할 수 있는 상태의 경우에는 애니메이션 몽타주를 사용하는 것이 편리함

-섹션
    - 트랙 개녀처럼 애니메이션 시퀀스의특정 위치를나타내는 정보
    - 이를 이용해 특정 섹션 실행 및 섹션구간 반복 등의 내용을처리할 수 있음
    
이벤트 끝날때 쯤(이부분에서지정) 발생해줘 하는 부분(이벤트를 발생 시ㅣ는 부분

애니메이션몽타주는 코드상에서 Play(), Stop() 기능을 호출함으로 써 재생을 제어함

슬롯
- 애니메이션 몽타주 데이터를 저장하는 변수 같은 것
- 저장된 슬롯을 애니메이션 블루프린트에서 가져다 사용함
- 언리얼은 기본으로 Default Slot을 제공
- 지금까지 작업하고 있는 몽타주 데이터가 저장되어 있음

네비게이션 Invoker
- Navigation Invoker : 맵이 엄청 큰 경우, 멀리 있는 적이 target을 찾아서 최적의 경로로 바로 이동하는 것은 부자연 스러움
- AI가 네비게이션 영역을 정해줄 수 있으면 해당 영역 안에 target이있을 때 이동하도록 처리할 수 있음
- AI가 이동하면 그에 따라 갖고 있는 내비게이션 데이터 영역도 갱신되도록 해야 함
- 네비게이션 데이터가 내비게이션 Invoker 기능을 갖고 있는 AI 근처에서 만들어 지도록 설정해 주어야 함







