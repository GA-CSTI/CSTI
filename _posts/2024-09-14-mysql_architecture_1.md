---
title: "MySQL 아키텍처 기본편"
excerpt: "MySQL 아키텍처 구성요소인 MySQL엔진과 스토리지엔진 영역을 정리합니다."
#layout: archive
categories:
 - Mysql
tags:
  - [mysql, mariadb]
#permalink: mysql-architecture
toc: true
toc_sticky: true
date: 2024-09-14
last_modified_at: 2024-09-14
comments: true
---
### 🚀MySQL 아키텍처
!["MySQL아키텍처"](https://github.com/user-attachments/assets/4443fdb1-0de8-46bb-904d-8cc0b7f06cac "MySQL 아키텍처")

MySQL의 아키텍처는 클라이언트의 연결 및 쿼리 요청을 담당하는 MySQL엔진영역과 데이터를 읽거나 쓰는 영역인 스토리지 엔진영역으로 구성되어 있습니다.

---
### 🚀MySQL엔진
MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL파서 및 전처리기, 옵티마이저가 중심을 이룹니다. 그리고 성능 향상을 위해 MylSAM의 키 캐시나 InnoDB의 버퍼풀과 같은 보조 저장소 기능이 포함되어 있습니다. 또한，MySQL은 표준 SQL(ANSI SQL용2) 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있습니다.

---

### 🚀스토리지 엔진
MySOL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고 실제 데이터를 디스크 스토리지에 저장하거 나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담합니다. MySOL 서버에서 MySOL 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있습니다. 대표적으로 현재는 MVCC, 트랜잭션, 단일행 잠금 등을 지원하는 InnoDB가 메인으로 쓰이고 있고 특수한 요건에 맞춰 SPIDER, BLACKHOLE, ROCKSDB, MEMORY 등의 다른 스토리지 엔진도 쓰이고 있습니다. 이번 글에서는 대표적으로 쓰이는 InnoDB 엔진에 대해서 간략하게 설명드리도록 하고 다른 스토리지 엔진에 대해서는 별도의 글로 다뤄보도록 하겠습니다.

---

### 🚀핸들러 API
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러(Handler) 요청이라고 하고, 여기서 사용되는 API를 핸들러 API라고 합니다. InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고받습니다. 이 핸들러 API를 통해 얼마나 많은 데이터(레코드) 접근이 있었는지 확인할 수 있습니다. 

핸들러 API 요청은 아래의 명령으로 확인할 수 있습니다.

```
"SHOW GLOBAL STATUS LIKE 'Handler%'"; 
```

위의 명령어를 수행하면 나타나는 핸들러 API 중 대표적인 항목에 대해 간단히 설명드리면 아래와 같습니다.


| Handler 통계 정보     | 증가하는 경우                                                                                   | 설명                                                          | 예시                                                                     |
| --------------------- | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------ |
| Handler_read_first    | Index Full Scan 시 가장 왼쪽 leaf page 접근, Index 기준 컬럼으로 order by column ASC limit 1    | 인덱스를 이용하여 데이터를 처음부터 순차적으로 읽을 때 증가   | `SELECT * FROM table ORDER BY column ASC LIMIT 1`                        |
| Handler_read_key      | Index 접근 시 (Index 수직 탐색)                                                                 | 인덱스를 이용하여 데이터를 찾을 때마다 증가                   | `SELECT * FROM table WHERE column = 'value'`                             |
| Handler_read_last     | Index Full Scan 시 가장 오른쪽 leaf page 접근, Index 기준 컬럼으로 order by column DESC limit 1 | 인덱스를 이용하여 데이터를 끝에서부터 순차적으로 읽을 때 증가 | `SELECT * FROM table ORDER BY column DESC LIMIT 1`                       |
| Handler_read_next     | Index Range Scan 시                                                                             | 인덱스 범위 내에서 데이터를 순차적으로 읽을 때 증가           | `SELECT * FROM table WHERE column BETWEEN 1 AND 10`                      |
| Handler_read_prev     | Index Range Scan 시 (역순)                                                                      | 인덱스 범위 내에서 데이터를 역순으로 읽을 때 증가             | `SELECT * FROM table WHERE column BETWEEN 10 AND 1` ORDER BY column DESC |
| Handler_read_rnd      | 인라인뷰 또는 sort 연산 이후                                                                    | 복잡한 쿼리 실행 시 임시 테이블 생성, 정렬 등으로 인해 증가   | 서브쿼리 사용, ORDER BY 절이 있는 복잡한 쿼리                            |
| Handler_read_rnd_next | 인덱스 없이 테이블 풀 스캔 시                                                                   | 인덱스 없이 테이블 전체를 순차적으로 읽을 때 증가             | `SELECT * FROM table` (인덱스가 없는 경우)                               |


---


### 🚀메모리 할당 및 사용구조

MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있습니다.
MySQL의 메모리 산정 시 이 두 영역에서 발생하는 메모리 점유를 고려하여야 합니다. 요즘에는 쉽게 계산할 수 있는 사이트도 있으니 참고하시기 바랍니다. 

[MySQL 메모리 계산기](https://www.mysqlcalculator.com/)


아래는 [마사토 유시오 블로그](https://masato.ushio.org/blog/index.php/2015/12/31/uco-tech_mysql-memory-usage/)님의 블로그에 있는 MySQL 메모리 영역과 디스크 영역을 나타낸 그림입니다.

![MySQL 메모리 영역과 디스크간 상관관계](https://github.com/user-attachments/assets/711c8e69-07ca-4298-b2d7-3a65bca06d91 "MySQL 메모리 영역과 디스크간 상관관계")


#### 1) 글로벌 메모리 영역
일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당됩니다. 단, 필요에 따라 두 개 이상의 메모리 공간을 할당받을 수도 있지만, 클라이언트 스레드의 수와는 무관하며 생성된 모든 글로벌 영역은 모든 스레드에 의해 공유되는 영역입니다. Data와 Redo Log 를 보관하는 메모리 영역이 이에 해당합니다. innodb_buffer_pool_size나 innodb_log_buffer_size 등의 파라미터를 통해 크기를 조절할 수 있습니다. 주요 글로벌 메모리 변경 파라미터는 아래와 같습니다.


- tmp_table_size
  - 설명 : MEMORY 및 TempTable 스토리지 엔진에서 생성하는 내부 인메모리 임시 테이블의 최대 크기를 정의합니다. 내부 인메모리 임시 테이블이 이 크기를 초과하면 자동으로 온디스크 내부 임시 테이블로 변환됩니다.
  - 적용 범위: 사용자가 생성한 MEMORY 테이블에는 적용되지 않습니다. 사용자가 생성한 TempTable 테이블은 지원되지 않습니다.
  - 제한: 내부 인메모리 임시 테이블에 MEMORY 스토리지 엔진을 사용할 때 실제 크기 제한은 tmp_table_size와 max_heap_table_size 중 작은 값입니다. max_heap_table_size 설정은 TempTable 테이블에는 적용되지 않습니다.
  - 설정: 고급 GROUP BY 쿼리를 많이 사용하고 메모리가 충분한 경우 tmp_table_size(및 필요한 경우 MEMORY 스토리지 엔진을 사용하여 내부 인메모리 임시 테이블을 사용할 때 max_heap_table_size)의 값을 늘리십시오.
  - 모니터링: 생성된 내부 온디스크 임시 테이블의 수와 생성된 내부 임시 테이블의 총 수를 비교하여 Created_tmp_disk_tables 및 Created_tmp_tables 값을 비교할 수 있습니다.

- innodb_buffer_pool_size
  - 설명 : InnoDB가 테이블 및 인덱스 데이터를 캐시하는 메모리 영역인 버퍼 풀의 크기를 바이트 단위로 지정합니다. 기본값은 134217728 바이트(128MB)입니다. 최대값은 CPU 아키텍처에 따라 다릅니다. 버퍼 풀의 크기가 1GB보다 클 때, innodb_buffer_pool_instances를 1보다 큰 값으로 설정하면 바쁜 서버에서 확장성을 향상시킬 수 있습니다. 전용 데이터베이스 서버에서는 버퍼 풀 크기를 시스템의 물리적 메모리 크기의 80%로 설정할 수 있습니다.
  - 주의사항: 버퍼 풀 크기는 항상 innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances와 같거나 배수여야 합니다.
  - 모니터링 : innodb_buffer_pool_size는 동적으로 설정할 수 있어 서버를 다시 시작하지 않고도 버퍼 풀 크기를 조정할 수 있습니다. Innodb_buffer_pool_resize_status 상태 변수로 변경사항을 확인할 수 있습니다.

- innodb_log_buffer_size
  - 설명: InnoDB가 디스크의 로그 파일에 쓰는 데 사용하는 버퍼의 크기를 바이트 단위로 지정합니다. 기본값은 64MB입니다. 큰 로그 버퍼를 사용하면 트랜잭션이 커밋되기 전에 로그를 디스크에 쓰지 않고도 큰 트랜잭션을 실행할 수 있습니다. 따라서 많은 행을 업데이트, 삽입 또는 삭제하는 트랜잭션이 있는 경우 로그 버퍼를 크게 하면 디스크 I/O를 절약할 수 있습니다.




#### 2) 로컬 메모리 영역
세션 메모리 영역이라고도 하며, MySQL 서버에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역입니다. 대표적으로 소트 버퍼 등이 있습니다. 그림 3-2에서 볼 수 있듯이 클라이언트가 MySQL 서버에 접속하면 MySQL 서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 합니다. 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 표현합니다.

로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있습니다. 일반적으로 글로벌 메모리 영역의 크기는 주의해서 설정하지만, 소트 버퍼와 같은 로컬 메모리 영역은 크게 신경 쓰지 않고 설정하는데, 최악의 경우(가능성은 희박하지만) MySQL 서버가 메모리 부족으로 멈춰 버릴 수도 있으므로 적절한 메모리 공간을 설정하는 것이 중요합니다. 로컬 메모리 공간의 또 한 가지 중요한 특징은 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL은 메모리 공간을 할당조차도 하지 않을 수도 있다는 점입니다. 대표적으로 소트 버퍼나 조인 버퍼와 같은 공간이 있습니다. 그리고 로컬 메모리 공간은 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간도 있고(커넥션 버퍼나 결과 버퍼) 그렇지 않고 쿼리를 실행하는 순간만 할당되었다가 다시 해제되는 공간(소트 버퍼나 조인 버퍼)도 있습니다.

주요 로컬 메모리 변경 파라미터는 아래와 같습니다.


- sort_buffer_size
  - 설명: 정렬 시 각 세션이 할당하는 버퍼 크기. ORDER BY, GROUP BY 작업 시 사용.
  - 적용범위: 특정 스토리지 엔진에 국한되지 않고 모든 정렬 작업에 적용.
  - 제한: 전역적으로 크게 설정하면 성능 저하. Linux에서 256KB 또는 2MB 이상의 값은 메모리 할당이 느려질 수 있음.
  - 설정: 필요에 따라 세션 단위로 설정하는 것이 좋음. 최소한 15개의 튜플을 수용할 수 있어야 함.
  - 모니터링: SHOW GLOBAL STATUS의 Sort_merge_passes로 모니터링 가능.

- read_buffer_size
  - 설명: MyISAM 테이블의 순차 스캔 시 사용되는 버퍼 크기.
  - 적용범위: MyISAM 테이블의 순차 스캔, ORDER BY 정렬, 대량 삽입 등 다양한 상황에 적용.
  - 제한: 값은 4KB의 배수여야 하며, 그렇지 않으면 가장 가까운 4KB 배수로 내림 설정됨.
  - 설정: 기본값은 131072, 필요시 늘릴 수 있음.
  - 모니터링: 메모리 사용량 및 성능 최적화 중 상태 모니터링 필요.

- read_rnd_buffer_size
  - 설명: MyISAM 테이블의 키 정렬 후 행을 읽을 때 사용되는 버퍼. Multi-Range Read 최적화에 사용.
  - 적용범위: MyISAM 테이블의 정렬된 데이터 읽기, Multi-Range Read 최적화.
  - 제한: 클라이언트별로 할당되는 버퍼이므로 전역 설정으로 크게 할당해서는 안 됨.
  - 설정: 대용량 쿼리 수행 시 세션별로 버퍼 크기를 조정.
  - 모니터링: 특정 쿼리의 성능을 주기적으로 모니터링하여 필요시 크기 조정.

- join_buffer_size
  - 설명: 인덱스를 사용하지 않는 조인이나 전체 테이블 스캔 시 사용되는 버퍼 크기.
  - 적용범위: 인덱스를 사용할 수 없는 경우, 조인이나 전체 테이블 스캔 시 성능 향상에 사용.
  - 제한: 기본값 256KB, 최대 4GB-1. 필요 이상으로 크면 성능 저하 발생.
  - 설정: 특정 쿼리에서만 조정하거나 SET_VAR 힌트를 통해 설정하는 것이 좋음.
  - 모니터링: 조인 성능을 모니터링하고 적정값을 설정.

- thread_stack
  - 설명: 각 스레드의 스택 크기. 저장 프로시저, 복잡한 SQL 문 처리 시 필요.
  - 적용범위: 모든 스레드에 적용.
  - 제한: 스택 크기가 작으면 SQL 처리 능력 및 메모리 집약적 작업이 제한됨.
  - 설정: 기본값은 충분하지만, 복잡한 작업을 위해 필요시 증가.
  - 모니터링: 복잡한 쿼리나 프로시저 실행 시 성능 확인.

- binlog_cache_size
  - 설명: 트랜잭션 중 바이너리 로그 변경 내용을 저장하는 메모리 버퍼 크기.
  - 적용범위: 서버에서 바이너리 로깅이 활성화된 경우, 각 클라이언트에 대해 적용.
  - 제한: 트랜잭션 데이터가 버퍼 크기를 초과하면 임시 파일로 전환.
  - 설정: 대용량 트랜잭션을 자주 사용하는 경우 크기를 늘려 임시 파일 사용을 줄임.
  - 모니터링: Binlog_cache_use와 Binlog_cache_disk_use 상태 변수를 통해 적정값 모니터링.

---

### 🚀쿼리 실행 구조

아래 그림은 RealMySQL 서적에 첨부된 쿼리 실행 구조입니다.

![image](https://github.com/user-attachments/assets/7b12cf09-2b07-425f-955c-99ff816ce912)


#### 1) 파서
파서는 사용자 요청으로 들어온 쿼리 문장을 토큰 (MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미합니다. 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되며 사용자에게 오류 메시지를 전달합니다.

#### 2) 전처리기
전처리기는 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인합니다. 각 토큰을 테이블 이름이나 칼럼 이름 또는 내장 함수와 같은 객체에 매핑해 해당 객체의 존재 여부와 접근 권한 등을 확인하는 작업을 이 단계에서 수행합니다. 실제 존재하지 않거나 권한상 사용할 수 없는 객체의 토큰은 이 단계에서 걸러집니다.

#### 3) 옵티마이저
옵티마이저는 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당합니다.

#### 4) 실행엔진 및 핸들러
옵티마이저가 두뇌라면 실행엔진과 핸들러는 손과 발에 비유할 수 있습니다. 옵티마이저가 수립한 실행계획을 토대로 스토리지 엔진에서 레코드를 읽고 쓰는 작업을 수행합니다.


---
{% assign posts = site.categories.Mysql %}
{% for post in posts %} {% include archive-single2.html type=page.entries_layout %} {% endfor %}