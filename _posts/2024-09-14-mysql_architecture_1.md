---
title: "MySQL 아키텍처 기본편"
excerpt: "MySQL 아키텍처 구성요소인 MySQL엔진과 스토리지엔진 영역을 정리합니다."
#layout: archive
categories:
 - Mysql
tags:
  - [mysql, mariadb]
#permalink: mysql-architecture
toc: true
toc_sticky: true
date: 2024-09-14
last_modified_at: 2024-09-14
comments: true
---
### 🚀MySQL 아키텍처
!["MySQL아키텍처"](https://github.com/user-attachments/assets/4443fdb1-0de8-46bb-904d-8cc0b7f06cac "MySQL 아키텍처")

MySQL의 아키텍처는 클라이언트의 연결 및 쿼리 요청을 담당하는 MySQL엔진영역과 데이터를 읽거나 쓰는 영역인 스토리지 엔진영역으로 구성되어 있습니다.

---
### 🚀MySQL엔진
MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL파서 및 전처리기, 옵티마이저가 중심을 이룹니다. 그리고 성능 향상을 위해 MylSAM의 키 캐시나 InnoDB의 버퍼풀과 같은 보조 저장소 기능이 포함되어 있습니다. 또한，MySQL은 표준 SQL(ANSI SQL용2) 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있습니다.

---

### 🚀스토리지 엔진
MySOL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고 실제 데이터를 디스크 스토리지에 저장하거 나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담합니다. MySOL 서버에서 MySOL 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있습니다. 대표적으로 현재는 MVCC, 트랜잭션, 단일행 잠금 등을 지원하는 InnoDB가 메인으로 쓰이고 있고 특수한 요건에 맞춰 spider,blackhole, rocksdb, memory 등의 다른 스토리지 엔진도 쓰이고 있습니다. 이번 글에서는 대표적으로 쓰이는 InnoDB 엔진에 대해서 간략하게 설명드리도록 하고 다른 스토리지 엔진에 대해서는 별도의 글로 다뤄보도록 하겠습니다.

---

### 🚀핸들러 API
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러(Handler) 요청이라고 하고, 여기서 사용되는 API를 핸들러 API라고 합니다. InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고받습니다. 이 핸들러 API를 통해 얼마나 많은 데이터(레코드) 접근이 있었는지 확인할 수 있습니다. 

핸들러 API 요청은 아래의 명령으로 확인할 수 있습니다.

```
"SHOW GLOBAL STATUS LIKE 'Handler%'"; 
```

위의 명령어를 수행하면 나타나는 핸들러 API 중 대표적인 항목에 대해 간단히 설명드리면 아래와 같습니다.


| Handler 통계 정보 | 증가하는 경우 | 설명 | 예시 |
|---|---|---|---|
| Handler_read_first | Index Full Scan 시 가장 왼쪽 leaf page 접근, Index 기준 컬럼으로 order by column ASC limit 1 | 인덱스를 이용하여 데이터를 처음부터 순차적으로 읽을 때 증가 | `SELECT * FROM table ORDER BY column ASC LIMIT 1` |
| Handler_read_key | Index 접근 시 (Index 수직 탐색) | 인덱스를 이용하여 데이터를 찾을 때마다 증가 | `SELECT * FROM table WHERE column = 'value'` |
| Handler_read_last | Index Full Scan 시 가장 오른쪽 leaf page 접근, Index 기준 컬럼으로 order by column DESC limit 1 | 인덱스를 이용하여 데이터를 끝에서부터 순차적으로 읽을 때 증가 | `SELECT * FROM table ORDER BY column DESC LIMIT 1` |
| Handler_read_next | Index Range Scan 시 | 인덱스 범위 내에서 데이터를 순차적으로 읽을 때 증가 | `SELECT * FROM table WHERE column BETWEEN 1 AND 10` |
| Handler_read_prev | Index Range Scan 시 (역순) | 인덱스 범위 내에서 데이터를 역순으로 읽을 때 증가 | `SELECT * FROM table WHERE column BETWEEN 10 AND 1` ORDER BY column DESC |
| Handler_read_rnd | 인라인뷰 또는 sort 연산 이후 | 복잡한 쿼리 실행 시 임시 테이블 생성, 정렬 등으로 인해 증가 | 서브쿼리 사용, ORDER BY 절이 있는 복잡한 쿼리 |
| Handler_read_rnd_next | 인덱스 없이 테이블 풀 스캔 시 | 인덱스 없이 테이블 전체를 순차적으로 읽을 때 증가 | `SELECT * FROM table` (인덱스가 없는 경우) |



### 🚀메모리 할당 및 사용구조

MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있습니다.
MySQL의 메모리 산정 시 이 두 영역에서 발생하는 메모리 점유를 고려하여야 합니다. 요즘에는 쉽게 계산할 수 있는 사이트도 있으니 참고하시기 바랍니다. 

[MySQL 메모리 계산기](https://www.mysqlcalculator.com/)

#### 1) 글로벌 메모리 영역
일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당됩니다. 단, 필요에 따라 두 개 이상의 메모리 공간을 할당받을 수도 있지만, 클라이언트 스레드의 수와는 무관하며 생성된 모든 글로벌 영역은 모든 스레드에 의해 공유되는 영역입니다. Data와 Redo Log 를 보관하는 메모리 영역이 이에 해당합니다. innodb_buffer_pool_size나 innodb_log_buffer_size 를 통해 크기를 조절할 수 있습니다.


| 변수명                   | 설명                                                                                                                                                                                                                                                                                     | 적용 범위                                                                                                                                                                                                                                                                             | 제한                                                                                                                                                                  | 설정                                                                                                                                                            | 모니터링                                                                                                         |
|--------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|
| tmp_table_size            | MEMORY 및 TempTable 스토리지 엔진에서 생성하는 내부 인메모리 임시 테이블의 최대 크기를 정의합니다. 내부 인메모리 임시 테이블이 이 크기를 초과하면 자동으로 온디스크 내부 임시 테이블로 변환됩니다.                                                                                                  | 사용자가 생성한 MEMORY 테이블에는 적용되지 않으며, 사용자가 생성한 TempTable 테이블은 지원되지 않습니다.                                                                                                                                                                                | 내부 인메모리 임시 테이블에 MEMORY 스토리지 엔진을 사용할 때, tmp_table_size와 max_heap_table_size 중 작은 값이 실제 크기 제한이 됩니다. max_heap_table_size는 TempTable 테이블에는 적용되지 않습니다.                               | 고급 GROUP BY 쿼리를 많이 사용하고 메모리가 충분한 경우 tmp_table_size(및 필요한 경우 max_heap_table_size)를 늘려야 합니다.                                                                            | Created_tmp_disk_tables 및 Created_tmp_tables 값을 비교하여 모니터링할 수 있습니다.                                    |
| innodb_buffer_pool_size   | InnoDB가 테이블 및 인덱스 데이터를 캐시하는 메모리 영역인 버퍼 풀의 크기를 바이트 단위로 지정합니다. 기본값은 128MB입니다. 최대값은 CPU 아키텍처에 따라 달라지며, 32비트 시스템에서는 4GB, 64비트 시스템에서는 16EB입니다.                                                                     | InnoDB 테이블과 인덱스 데이터를 캐시하는 데 사용됩니다.                                                                                                                                                                                                                                  | 물리적 메모리 크기의 80%로 설정 가능하지만, 과도한 설정으로 인해 페이징이 발생할 수 있습니다. 버퍼 풀 크기가 1GB 이상일 때는 innodb_buffer_pool_instances를 1보다 큰 값으로 설정해야 합니다.                                           | 전용 데이터베이스 서버일 경우 물리적 메모리의 80%로 설정하는 것이 권장되며, 운영 체제에서 페이징이 발생하지 않도록 주의해야 합니다.                                                                    | 온라인 버퍼 풀 크기 조정 시, Innodb_buffer_pool_resize_status 상태 변수를 통해 모니터링할 수 있습니다.                        |
| innodb_log_buffer_size    | InnoDB가 디스크의 로그 파일에 쓰는 데 사용하는 버퍼의 크기를 바이트 단위로 지정합니다. 기본값은 64MB입니다. 로그 버퍼가 크면 큰 트랜잭션을 커밋하기 전에 로그를 디스크에 쓰지 않아도 되어 디스크 I/O를 줄일 수 있습니다.                                                                       | InnoDB 트랜잭션 로그 버퍼에 적용됩니다.                                                                                                                                                                                                                                                | 로그 버퍼가 클수록 많은 행을 업데이트, 삽입, 삭제하는 트랜잭션에서 디스크 I/O가 줄어듭니다.                                                                                                              | 로그 버퍼 크기를 트랜잭션 크기에 맞게 조정하면, I/O 성능을 최적화할 수 있습니다.                                                                                                                         |                                                                                                                                                                          |




#### 2) 로컬 메모리 영역
세션 메모리 영역이라고도 하며, MySQL 서버에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역입니다. 대표적으로 소트 버퍼 등이 있습니다. 그림 3-2에서 볼 수 있듯이 클라이언트가 MySQL 서버에 접속하면 MySQL 서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 합니다. 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 표현합니다.

로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있습니다. 일반적으로 글로벌 메모리 영역의 크기는 주의해서 설정하지만, 소트 버퍼와 같은 로컬 메모리 영역은 크게 신경 쓰지 않고 설정하는데, 최악의 경우(가능성은 희박하지만) MySQL 서버가 메모리 부족으로 멈춰 버릴 수도 있으므로 적절한 메모리 공간을 설정하는 것이 중요합니다. 로컬 메모리 공간의 또 한 가지 중요한 특징은 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL은 메모리 공간을 할당조차도 하지 않을 수도 있다는 점입니다. 대표적으로 소트 버퍼나 조인 버퍼와 같은 공간이 있습니다. 그리고 로컬 메모리 공간은 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간도 있고(커넥션 버퍼나 결과 버퍼) 그렇지 않고 쿼리를 실행하는 순간만 할당되었다가 다시 해제되는 공간(소트 버퍼나 조인 버퍼)도 있습니다.

---
{% assign posts = site.categories.Mysql %}
{% for post in posts %} {% include archive-single2.html type=page.entries_layout %} {% endfor %}