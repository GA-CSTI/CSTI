---
layout: single
title: 변수와 바인딩에 대해서
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---
목표 D-day : 25 일

오늘은 변수와 바인딩에 대해서 학습한 내용을 정리하려고 합니다.

변수는 개발자가 사용하기 편하도록 추상화된 메모리 공간입니다.

## 학습 목표

+ 변수의 개념을 이해하고 변수의 속성을 누군가에게 설명할 수 있게 공부한다.
+ 바인딩의 개념을 이해하고 정적 바인딩과 동적 바인딩의 차이를 설명할 수 있어야한다.
+ 주소 바인딩 개념을 설명할 수 있어야한다.



### 변수의 개념

프로그램은 데이터 처리를 위해 필요한 자료를 저장하는 공간이 필요하며, 개발자가 사용하기 편하도록 추상화된 공간을 말합니다.



### 변수의 속성

변수는 변수명, 타입, 주소, 값으로 구성되어있습니다.

```java
class variable<T> {
    String name;
    Type type;
    long memoryAddress;
    T value;
}
```

제가 생각하는 변수를 java 클래스로 코드로 표현해보았습니다.

변수명은 프로그램 내에서 접근할 수 있는 식별자입니다.

식별자는 동일한 이름이 존재하지 않아야 합니다. 만약 동일한 식별자가 있다면 우선 순위가 있지 않는 이상 잘못된 값을 읽어오게 되며 예상하지 못한 결과가 반환될 수 있습니다.

따라서 변수를 선언할 때 제일 중요한 것은 변수 명을 입력하는 것입니다.(물론 변수명이 없을 수 있습니다.)

타입은 사용하려는 메모리의 크기와 연산을 결정하게 합니다.

만약 타입이 `int`라면 메모리 크기는 4바이트, 그리고 사칙연산 외 다른 int 타입이 제공하는 연산을 사용할 수 있습니다.

#### 타입 안정성

개발을 하다보면 타입 안정성을 이야기합니다.

타입 안정성은 **A 연산자 B = C** 라고 한다면 C도 A와 동일한 타입을 갖고 있다는 의미입니다.

예를 들어 `int num = 3/2`에서 `num`의 값은 1을 갖습니다. 

`int` 자료형끼리 연산을 하는 경우 결과도 동일한 `int`자료형이 나올 경우 타입 안정성이 있다고  합니다.

#### 주소

실제 데이터의 주소를 말합니다.



### 바인딩

바인딩은 추상화된 변수에 구체적인 값을 넣는 작업을 말합니다.

변수 명에 이름을 넣는다, 타입에 `int`로 선언한다, 주소에 `메모리 주소`를 넣는다, 값에 `value(실제 값)`을 넣는 것을 말합니다.



```java
int totalPrice;
totalPrice = 1000 + 1200 * 5;
if(totalPrica < 4000) {
    ...
}
...
```



#### 정적 바인딩과 동적 바인딩

정적 바인딩은 정해진 이후로 변경되지 않는 것을 말합니다.

그러면 타입 정적 바인딩, 주소 정적 바인딩이 있습니다.

이것도 같습니다

타입 정적 바인딩은 타입이 한번 정해지면 변경되지 않는 것을 말합니다.

예를 들어 자바와 코틀린이 타입 정적 바인딩에 해당합니다.

```java
int number = 5;
number = "5";
```

처음 결정된 타입은 변경되지 않습니다.

하지만 타입 동적 바인딩은 

```java
int number = 5;
number = "5";
```

이렇게 할당하려는 값에 따라 타입이 변경되는 것을 말합니다.



그리고 비슷한 예로 주소 정적 바인딩은 한번 할당받은 메모리 주소가 변경되지 않는 것을 말합니다.

```java
static Member number = new Member() ;
public static Member createMember(){...};
```

메서드와 변수 모두 고정된 주소를 가지며 몇 번을 호출해도 동일합니다.



다만 주소 동적 바인딩은 다릅니다.

```java
class Member {
    int age;
    public Member createMember(){..}
}
```

해당 멤버 변수와 메서드는 다른 위치에 저장됩니다. 왜일까요?

메서드는 해당 클래스가 모두 동일한 메서드를 가지고 있으므로 효율적으로 사용하기 위해 정적 바인딩으로 관리합니다.

하지만 멤버 변수는 인스턴스마다 다른 주소를 가지고 있어야하므로 동적 바인딩이 됩니다.

그러면 오버로딩과 오버라이딩은 어떤 바인딩일까요?

오버로딩은 정적 바인딩, 오버라이딩은 동적바인딩입니다.

오버로딩은 컴파일 시점에 메서드 위치가 정해져있으므로 정적 바인딩으로 됩니다.

오버라이딩은 동적 바인딩입니다. 컴파일 이후에 런타임 시점에 어떤 타입을 사용하는지에 따라 실행되는 메서드가 다르기 때문에 동적 바인딩으로 달라집니다.

동적바인딩은 유연함을 주고 정적 바인딩은 큰 차이는 아니지만 최적화가 잘되어있습니다.
