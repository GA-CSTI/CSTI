---
layout: single
title: 서블릿과 멀티프로세스
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---
목표 D-day : 83 일

## 학습목표

1. 운영체제 기본인 멀티테스킹
2. 서블릿



### 멀티태스킹 (Multitasking)

멀티태스킹은 하나의 CPU 코어가 여러 프로그램(또는 프로세스)를 운영체제의 스케줄링에 따라 번갈아 가며 실행하는 것을 의미합니다.

이는 프로세스 간의 빠른 전환(`Context Switching`)을 통해 이루어지며, 사용자에게 여러 프로그램이 동시에 실행되는 것처럼 보이게 합니다.

#### 스케줄링

할 일이 많을 때 어떤 기준에 따라 일의 순서를 정하고 처리하는 것을 스케줄링이라고 하고 현재 실행중인 각각의 일을 프로세스라고 합니다.

**일의 순서를 왜 정할까?**

CPU는 하나 뿐인데 처리해야하는 일이 많기 때문입니다.

1. 프로세스 스케줄링

   : CPU 자원을 여러 프로세스가 효율적으로 사용하도록 순서를 결정하는 방법입니다.

   - **라운드 로빈 (Round Robin)**: 프로세스들에게 시간 단위로 순차적으로 CPU를 할당하여 공정성을 보장합니다.
   - **우선순위 스케줄링 (Priority Scheduling)**: 각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스에게 CPU를 먼저 할당합니다.
   - **멀티 레벨 큐 (Multi-level Queue)**: 프로세스를 여러 우선순위 큐로 나누어, 각 큐에 다른 스케줄링 알고리즘을 적용합니다.

2. 디스크 스케줄링

   : 디스크 암(arm) 또는 헤드의 이동 순서를 결정하는 과정입니다.

   - **FCFS (First-Come, First-Served)**: 디스크 요청이 도착한 순서대로 처리합니다.
   - **SSTF (Shortest Seek Time First)**: 가장 가까운 위치의 데이터 요청을 먼저 처리하여 디스크 접근 시간을 최소화합니다.
   - **SCAN**: 디스크 헤드가 끝까지 이동한 후 반대 방향으로 이동하면서 요청을 처리합니다.
   - **C-SCAN**: 디스크 헤드가 끝까지 이동한 후 처음으로 돌아와 다시 같은 방향으로 요청을 처리합니다.

### 멀티 프로세싱 (Multiprocessing)

컴퓨터 시스템의 처리능력을 높이기 위하여 2대 이상의 CPU를 이용하여 2개 이상의 작업을 동시에 병렬로 처리하는 형태를 말합니다.

**멀티 프로세싱이 등장한 이유**

하나의 CPU 코어로는 아무리 성능을 향상시킨다 해도 많은 작업을 신속히 처리하는 데 한계가 있습니다.

**트레이드오프**

시스템의 종합적인 처리 능력을 증가시키지만, 개별 프로그램으로 볼때는 여전히 1개의 코어로 하나의 작업을 처리하고 있는 셈이며, 오히려 다중 작업 때문에 기다리는 시간이 늘어날 수도 있기 때문입니다.

### 정리

#### 멀티프로세싱

- **정의**: 여러 CPU(또는 여러 CPU 코어)를 사용하여 동시에 여러 작업을 수행하는 것을 의미합니다.
- **기반**: *하드웨어 기반*으로 성능을 향상시킵니다.
- **예시**: 다중 코어 프로세서를 사용하는 현대 컴퓨터 시스템.

#### 멀티태스킹

- **정의**: 단일 CPU(단일 CPU 코어)가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것을 의미합니다.
- **기반**: *소프트웨어 기반*으로 CPU 시간을 분할하여 각 작업에 할당합니다.
- **예시**: 현대 운영 체제에서 여러 애플리케이션이 동시에 실행되는 환경. (여기서 주의할 점은, 현대 운영 체제는 일반적으로 멀티코어를 사용하기 때문에, 이는 멀티프로세싱과 멀티태스킹이 결합된 형태로 운영됩니다.)

현대 컴퓨터 시스템은 여러 CPU 코어(또는 멀티코어)를 사용하기 때문에 멀티프로세싱을 수행합니다. 동시에 각각의 단일 CPU 코어가 여러 작업을 분할해서 수행하기 때문에 멀티태스킹도 수행합니다. 이는 두 개념이 함께 사용되어 시스템의 효율성과 성능을 극대화하는 예시입니다.

## 프로세스

프로세스(process)는 컴퓨터에서 실행중인 프로그램(일, task)을 뜻합니다.

프로세스는 생성 – 준비 – 실행 – 대기 – 소멸 5가지 상태를 반복합니다.

**프로세스의 상태**

1. **생성 (New)**: 프로세스가 생성되어 운영체제에 등록된 상태.
2. **준비 (Ready)**: 프로세스가 실행을 기다리고 있는 상태. CPU 할당을 대기 중.
3. **실행 (Running)**: 프로세스가 CPU를 할당받아 실제로 실행 중인 상태.
4. **대기 (Waiting)**: 프로세스가 I/O 작업 등으로 인해 일시적으로 중단된 상태. 다시 준비 상태로 돌아가기 위해 대기 중.
5. **소멸 (Terminated)**: 프로세스의 실행이 완료되어 메모리에서 해제된 상태.



### 서블릿

서블릿은 자바 Java EE 표준의 일부로, 웹 애플리케이션의 서버 측 로직을 구현하는 데 사용됩니다.

서블릿은 HTTP 요청/응답 사이클을 처리하는 데 주로 사용되며, 이를 통해 동적인 웹 컨텐츠를 생성할 수 있습니다.



**서블릿 컨테이너와 설정**

서블릿 컨테이너는 서블릿의 생명 주기를 관리하며 공통으로 사용하는 설정은 `ServletContext`를 사용하고, 개별 서블릿이 필요한 설정으로 `ServletConfig`를 통해서 독립적인 설정도 가능합니다.

+ `ServletContext`는 애플리케이션 범위에서 공유되는 자원을 관리하고 설정값을 공유할 수 있게 해줍니다.

+ `ServletConfig`는 특정 서블릿에 대한 초기화 파라미터를 설정하고 관리하는 데 사용됩니다.

설정 방식은 `xml`을 통해서 설정이 가능하며, 또는 서블릿에서 `getServletContext()`를 통해서 설정 추가 및 조회도 가능합니다.



**서블릿 등록 방법**

서블릿을 등록하는 방법은 `xml`을 사용하는 방법과 `@어노테이션`을 사용하는 방법이 있습니다.

각자의 장단점은 명확합니다.

어노테이션으로 구현할 경우 서블릿을 등록하고, `Url`매핑하는 과정은 간단하지만 애노테이션 내에 코드를 변경할 경우 재컴파일을 해야합니다. 하지만 `xml`을 통해 서블릿을 등록하는 경우 설정이 복잡하지만 관련된 설정을 변경하여도 구현 코드는 변경하지 않아도 된다는 장점이 있습니다.

 어노테이션 예제:

```java
@WebServlet("/example")
public class ExampleServlet extends HttpServlet {
    // 서블릿 코드
}
```

`web.xml` 예제:

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>com.example.ExampleServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>ExampleServlet</servlet-name>
    <url-pattern>/example</url-pattern>
</servlet-mapping>
```

**서블릿 인터페이스 구현**

서블릿을 등록하기 위해서는 서블릿의 기본 인터페이스인 `Servlet`을 구현해야합니다.

자바는 공식적으로 `HTTP`를 처리할 수 있는 구현체인 `HttpServlet`을 제공하고 있으므로 해당 구현체를 상속하여 재정의합니다.

**서블릿 생명 주기**

서블릿은 요청이 들어올 때 생성되지만, `load-on-startup` 설정을 통해 서블릿을 미리 로드할 수 있습니다. 

서블릿의 생명 주기는 `init()`, `service()`, `destroy()` 메서드로 관리되며, 초기화, 요청 처리, 리소스 해제 작업을 수행할 수 있습니다.



### MVC 패턴

MVC 패턴은 집 구조와 같다고 생각할 수 있습니다.

예를 들어, 화장실, 주방, 안방을 모두 하나의 방에 포함시키면, 한 곳을 청소할 때 다른 모든 영역에 영향을 미치게 됩니다. 이는 유지 보수가 어렵고, 각 부분을 독립적으로 관리하기 어렵게 만듭니다.

이와 반대로, 각 기능을 별도의 공간으로 분리하면, 화장실을 청소할 때 주방과 안방에 영향을 미치지 않게 됩니다. 이렇게 각 공간을 독립적으로 유지하고 관리할 수 있기 때문에, 필요에 따라 각 부분을 개별적으로 유지보수할 수 있습니다.

### 핵심 개념: 관심사의 분리

제가 생각하는 MVC 패턴의 핵심은 **관심사를 어떻게 분리하는지**입니다.

- **뷰(View)**:
  - 사용자가 마주하는 화면입니다.
  - 비즈니스 로직이 변경되지 않더라도 UI는 변경될 수 있습니다.
  - 예: UI 디자인 변경, 사용자 인터페이스 개선 등.

- **모델(Model)**:
  - 애플리케이션의 비즈니스 로직과 데이터 처리를 담당합니다.
  - 화면이 동일하더라도 비즈니스 로직은 정책에 따라 다른 결과를 보여줄 수 있습니다.
  - 예: 데이터베이스 접근, 비즈니스 규칙 적용 등.

- **컨트롤러(Controller)**:
  - 사용자의 요청을 처리하고, 올바른 모델과 뷰를 선택합니다.
  - 비즈니스 로직을 실행하기 위해 사용자의 요청 값 검증이나 인증 확인이 필요합니다.
  - 예: 폼 데이터 검증, 사용자 인증 등.

### 유지보수의 용이성

이렇게 수정되는 시기와 목적에 따라 각 구성 요소를 분리하면, 다음과 같은 장점을 얻을 수 있습니다:

- **유지보수성 향상**:
  - UI 변경과 비즈니스 로직 변경이 독립적으로 이루어질 수 있습니다.
  - 특정 기능을 변경할 때 다른 기능에 영향을 미치지 않으므로, 버그 발생 가능성이 줄어듭니다.

- **재사용성 증가**:
  - 모델, 뷰, 컨트롤러를 독립적으로 개발하고 테스트할 수 있습니다.
  - 동일한 비즈니스 로직을 여러 화면에서 재사용할 수 있습니다.

- **테스트 용이성**:
  - 각 구성 요소를 독립적으로 테스트할 수 있으므로, 단위 테스트와 통합 테스트가 용이해집니다.
