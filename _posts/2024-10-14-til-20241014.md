---
layout: single
title: crytograhy 암호화
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../

---

목표 D-day : 51 일

오늘은 대칭키 / 비대칭키 / 양방향 암호화 / 단방향 암호화에 대해서 학습하려고 합니다.

## 암호화

클라이언트가 서버에게 데이터를 전달합니다.

인터넷을 타고 여러 번 라우터를 거친 뒤 도착지까지 갈 동안 데이터는 다른 사람들이 볼 수 있습니다.



클라이언트가 서버에게 개인정보를 그대로 전달한다면 개인 정보 유출이 발생할 수 있습니다.

그래서 클라이언트는 서버에 전송할 데이터를 암호화해서 전달하고 , 데이터를 받은 서버는 복호화를 해서 전달된 데이터를 확인합니다.

전송할 데이터는 `3` 이라면 암호화를 위한 코드로 `4`가 있다고 한다면 `3 * 4 = 12`로 서버에 전달합니다.

서버가 읽기 전까지 `12`라는 데이터로 전달되기 때문에 전송하는 데이터를 알 수 없습니다.

서버는 `4`라는 암호화 코드를 반대로 복호화하여 `12 / 4 = 3`으로 클라이언트가 `3`을 전송한 것을 확인할 수 있습니다.

### 대칭키

암호화를 위한 키가 클라이언트와 서버가 동일한 경우를 **대칭키**라고 하며 서버와 클라이언트는 동일한 암호 코드를 가지고 있습니다.

대칭키는 암호방식과 복호화방식이 동일하여 빠르며, 많은 데이터 처리, 크기가 작은 암호키가 큰 장점입니다.

다만, 최초 서버에 접속할 때 대칭키를 가진 쪽에서 없는 쪽에게 대칭키를 전달해야 합니다.

이 과정에서 대칭키가 유출될 수 있으므로 보안이 안전하지 않습니다.



### 비대칭키

데이터를 암호화할 때 필요한 코드와 암호화된 정보를 데이터로 복호화에 필요한 코드가 다른 경우를 말합니다.

전송하려는 데이터가 `3` 이고 암호화 코드는 `@` 으로 암호화된 정보는 `!@%`으로 변경되어 서버에 전달됩니다.

서버는 `!@%`를 `%` 라는 복호화 코드로 해석하여 `3`으로 데이터를 읽습니다.

그러다 보니 암호화를 위한 코드를 클라이언트에게 전달하다가 유출해도 다른 사용자가 유출된 암호화 코드를 통해 개인정보를 복호화 할 수 없습니다.

복호화는 서버에 저장된 `%`(개인키)로만 복호화가 가능하기 때문에 대칭키보다 안전하게 암호화가 가능합니다.



### HTTP와 HTTPS

HTTP는 클라이언트와 서버간 네트워크 통신을 효율적으로 하기 위해 정해진 규칙입니다.

택배를 보내기 위해 필요한 송장과 동일합니다.

데이터를 전송하는 측과 데이터를 받는 측 정보, 내용물이 어떤 형식으로 인코딩 되어 있는지 작성되어있습니다.



클라이언트와 서버가 네트워크 통신을 HTTP로 요청/응답을 할때

인터넷으로 통신하기 때문에 정보 유출이 발생할 수 있습니다.



네이버는 개인키를 가지며 사용자에게 공개키를 전달합니다.

사용자는 공개키로 네이버에 전송할 데이터를 암호화하여 전달합니다.

공개키가 유출되어도 사용자가 암호화한 정보는 공개키로 복호화가 되지 않기 때문에 안전합니다.



이때 암호화된 정보를 네이버에게 전달할 때 

사용자는 자신이 전달하는 곳이 네이버인지 확인할 필요가 있습니다.

네이버는 자신이 사용자에게 전송하는 데이터중 일부를 네이버의 개인키로 암호화하여 전달합니다. 

사용자가 받은 네이버 공개키는 네이버의 개인키로 암호화된 정보만 복호화할 수 있습니다.

그래서 다른 피싱 사이트에서 자신들의 개인키로 암호화된 정보를 보내도 네이버의 공개키로 열어볼 수 없습니다.



이제 네이버의 공개키가 신뢰할 수 있는 공개키인지 확인만 한다면 

사용자는 네이버의 공개키를 사용하여 데이터를 암호화하여 네이버에 전송할 수 있습니다.



이걸 인증하는 민간 기업이 `CA (Certificate Authority`) 라고합니다.

사용자가 사용하는 브라우저(`크롬, 웨일, 기타 등등`)은 CA 의 목록이 저장되어 있습니다.



클라이언트와 서버가 최초 연결시 3-hand shake 를 할때 서버측은 해당 서버의 인증서도 같이 전송합니다.

클라이언트는 서버가 전송한 인증서가 신뢰할 수 있는지 확인하기 위해 내장된 CA들의 정보를 통해서 확인합니다.



사이트 인증서는 CA의 개인 키로 암호화가 되어있습니다. 

브라우저에 내장된 CA의 공개 키로 복호화를 할 수 있습니다.

내장된 CA의 공개키로 사이트 인증서가 복호화가 안된다면 신뢰할 수 없는 인증서가 됩니다.



사이트 인증서가 내장된 공개키로 복호화가 된다면 신뢰할 수 있는 인증서가 되며

인증서를 복호화하면 서버의 공개키가 포함되어 있습니다. 이 공개키로 비대칭 방식으로 통신할 수는 있습니다.



하지만 비대칭 방식으로 데이터를 암호화하여 통신하는 방법은 서버에 부하를 줄 수 있으므로 대칭방식과 비대칭 방식을 혼합하여 사용합니다.

대칭키를 사용하는 이유는 사이트와 통신할 때 대량의 데이터를 모두 비대칭으로 하나씩 암호화하고 복호화하는건 무리가 되기 때문입니다. 그래서 데이터 암호화 , 복호화는 대칭키로 암호화합니다. 



처음 서버와 연결할 때 주고 받은 데이터를 혼합하여 임시키로 만들고 서버의 공개키로 암호화하여 서버에 전송합니다.

서버는 개인키로 임시키를 복호화합니다. 이후 일련의 과정이 지나서 동일한 대칭키를 만들어지게 되고 이후로는 대칭키를 통해서 데이터를 요청/응답하게 됩니다.

이 대칭키는 서버와 클라이언트만 가지고 있으므로 안전하게 사용할 수 있습니다.





### 인코딩과 디코딩

대학교 과목 수업중에서 사람과 사람이 대화를 할 수 있는건 언어라는 약속이 있듯이 컴퓨터와 개발자간 대화를 하기 위해서는 코드(=code)를 통해 의사소통이 가능합니다.

인코딩은 실제하는 정보를 컴퓨터가 이해할 수 있는 방식으로 코드로 만든 것이며

디코딩은 컴퓨터가 저장한 코드를 약속된 방식으로 실제 정보로 변환하는 것을 말합니다.

 

### [단방향 암호화 방법]

Hash라고 합니다
해시는 사전적 의미로 고기와 감자를 잘게 다진다고 합니다. 해시포테이토를 생각하면 됩니다.
데이터를 해시 알고리즘으로 변환하면 원래 상태로 되돌릴 수 없습니다.

#### 단방향 암호화(해싱)의 원리
해시 함수는 임의의 크기의 데이터를 고정된 크기의 해시 값으로 변환합니다.
예를 들어 SHA-256은 입력값이 아무리 길어도 64자(256비트)길이의 해시 값을 생성합니다.

중요한 특징으로 단방향성입니다.
해시 값에서 원래의 입력값(데이터)을 유추하는 것은 거의 불가능합니다.
이는 crytograhy 특징인 무결성을 보장합니다.

무결성이란 원본 데이터가 조작되거나 훼손되지 않으면 해시의 결과물은 항상 동일하다는 의미입니다.

#### 충돌 공격
해시 충돌은 두 개의 서로 다른 입력이 동일한 해시 값을 생성하는 경우를 말합니다.
변환된 결과의 고정된 길이가 작을 수록 해시 값의 경우의 수가 상대적으로 작습니다.
MD5,SHA-1과 같은 경우 보안상 취약하여 보안에 사용되지 않습니다.

#### 솔트
비밀번호 해시에서 자주 사용되는 개념 중 하나가 솔트입니다.
솔트는 해시 함수에 추가적으로 더하는 임의의 값으로 동일한 비밀번호라도 솔트 값에 따라 해시 값이 달라집니다.

따라서 솔트를 사용하면 레인보우 테이블(미리 계산된 해시 값으로 비밀번호를 찾는 공격)에 대한 방어가 가능합니다.

#### 단방향 암호화 활용
1. 비밀번호 저장:   
사용자 비밀번호는 평문으로 저장하지 않고 해시 함수로 처리한 후 저장해야합니다.
이는 데이터베이스가 유출되더라도 비밀번호가 노출되지 않도록 보호할 수 있습니다.

2. 데이터 무결성 체크:  
파일이나 메세지의 전송 과정에서 조작이 발생했는지 확인하기 위해 해시 값을 비교할 수 있습니다.
전자서명, 파일의 식별자에 활용 가능합니다.
