---
layout: single
title: 물리적 삭제와 논리적 삭제
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---
목표 D-day : 58 일



## 학습 목표

논리적 삭제와 물리적 삭제의 개념과 사용 사례를 이해한다.

## 키워드

**논리적 삭제(Soft Delete)**

1. 상태 플래그
2. 기록 보존
3. 복구 가능

**물리적 삭제(Hard Delete)**

1. 디스크 공간 확보
2. 영구 삭제
3. 복구 불가

## 물리적 삭제

`Hard Delete`는 해당 레코드가 테이블에서 완전히 삭제되는 방식입니다. 삭제된 후에는 사용자가 해당 레코드의 존재 여부를 확인할 수 없습니다.

**장점**

1. **디스크 공간 절약**: 물리적으로 데이터를 제거하기 때문에 디스크 공간을 절약할 수 있습니다.
2. **성능 최적화**: 삭제된 데이터에 접근할 필요가 없으므로, 인덱스 크기가 작아지고 조회 성능이 개선될 수 있습니다.
3. **개인 정보 보호**: 민감한 데이터를 영구적으로 삭제하여 정보 유출 위험을 줄입니다.
4. **단순성**: 별도의 상태 관리가 필요하지 않으며, 테이블에서 데이터가 완전히 제거되므로 관리가 간단합니다.

**한계**

1. **데이터 복구 불가능**: 물리적으로 제거된 데이터는 복구가 불가능합니다.
2. **감사 기록 부족**: 물리적 삭제는 데이터가 언제, 왜 삭제되었는지 기록을 남기지 않기 때문에, 추적이 어렵습니다.
3. **외래 키 제약 문제**: 외래 키가 설정된 경우, 관련된 다른 테이블의 데이터도 함께 삭제해야 하거나 삭제가 불가능할 수 있습니다.
4. **데이터 이력 관리 어려움**: 데이터를 삭제하므로 과거 데이터에 대한 이력을 관리하거나 불러오기 어렵습니다.

**해결 방안**

1. **논리적 삭제**를 사용하여 복구와 이력 관리를 지원할 수 있습니다.
2. **Audit Table**을 도입하여 삭제 로그를 저장하고, 데이터 이력을 관리할 수 있습니다. 이 경우:
   - 별도의 저장 관리가 필요합니다.
   - 테이블에서 수행되는 작업을 추적할 수 있습니다(누가, 무엇을, 언제).

## 논리적 삭제

`Soft Delete`는 데이터를 실제로 삭제하지 않고, 삭제된 것으로 표시하는 방식입니다. 이를 위해 일반적으로 상태를 나타내는 플래그 필드를 사용합니다.

**장점**

1. **데이터 복구 용이성**: 데이터가 실제로 삭제되지 않기 때문에 복구가 간단합니다.
2. **이력 관리**: 삭제된 데이터를 포함한 전체 이력을 추적할 수 있습니다. 이는 플래그 필드(`delete_yn` 등)를 통해 관리할 수 있습니다.
3. **참조 무결성 유지**: 데이터가 논리적으로만 삭제되기 때문에, 다른 테이블에서의 참조 무결성이 유지됩니다.

**한계**

1. **쿼리 복잡성 증가**: 데이터를 조회할 때 논리적 삭제된 데이터를 제외하는 로직이 필요하여 쿼리가 복잡해질 수 있습니다. 실수로 삭제된 데이터를 포함한 결과를 조회할 위험도 있습니다.
2. **성능 저하**: 삭제된 데이터도 유지되기 때문에 데이터베이스 크기가 계속 증가할 수 있습니다. 이로 인해 인덱스 크기 증가, 쿼리 성능 저하, `unique` 제약 조건 위반 등의 문제가 발생할 수 있습니다.

**해결 방안**

1. **ORM 활용**: 쿼리 복잡성 문제는 ORM을 사용하거나 삭제 플래그 필드의 이름을 통일하여 해결할 수 있습니다.
2. **데이터 관리**: 데이터베이스의 크기가 지나치게 커지는 문제는 주기적인 아카이빙 또는 물리적 삭제와 결합하여 해결할 수 있습니다.



## 언제 사용해야 할까

### 물리적 삭제 (Hard Delete)

1. 데이터 복구가 필요 없는 경우
2. 데이터베이스 성능이 중요한 경우
3. 데이터베이스 크기 관리가 필요한 경우
4. 데이터 일관성이 중요한 경우

현재 유효한 레코드만 필요한 테이블이라면 `Hard Delete`가 적합합니다. 그러나 데이터 이력 관리가 필요한 경우에는 `Audit Table`을 도입하는 것이 좋습니다.

### 논리적 삭제 (Soft Delete)

1. 데이터 복구 및 추적이 필요한 경우
2. 참조 무결성 유지가 필요한 경우 (`1:N 관계` 등)
3. 비즈니스 규칙에 따라 일정 기간 비활성화가 필요한 경우

레코드의 사용 이력을 관리하거나 레코드의 양이 많지 않은 경우라면 논리적 삭제가 더 관리하기 용이합니다.

## 결론

- **Hard Delete**는 데이터 복구가 불필요하고, 데이터베이스 성능과 공간 최적화가 중요한 경우에 적합합니다.
- **Soft Delete**는 데이터 복구, 이력 관리, 참조 무결성 유지가 중요한 경우에 적합합니다.



## 참조

+ [A Good Day to Delete Hard](https://medium.com/analytics-vidhya/a-good-day-to-delete-hard-22b8be83b622)
+ [soft delete 와 hard delete 비교](https://velog.io/@yhlee9753/soft-delete-%EC%99%80-hard-delete-%EB%B9%84%EA%B5%90)
