---
title: "[MongoDB] MongoDB WiredTiger 스토리지 엔진"
excerpt: "MongoDB의 메인 스토리지 엔진인 WiredTiger의 특징을 정리합니다."
#layout: archive
categories:
 - Mongodb
tags:
  - [mongodb]
#permalink: mongodb-first
toc: true
toc_sticky: true
date: 2024-09-15
last_modified_at: 2024-09-15
comments: true
---
### 🚀 MongoDB WiredTiger 스토리지 엔진
---
WiredTiger는 Berkeley DB 개발자들에 의해 개발된 임베디드 데이터베이스 엔진으로, 2014년 12월 MongoDB에 인수되어 현재 MongoDB의 디폴트 스토리지 엔진으로 도입되었습니다. MongoDB가 WiredTiger 스토리지 엔진을 도입하기 전에는 MMAPv1 스토리지 엔진을 사용했는데, 실제로 MMAPv1 스토리지 엔진은 범용적으로 사용하기에는 상당히 많은 문제점이 있었습니다. 따라서 MongoDB는 MMAPv1 스토리지 엔진의 문제점을 해결하기 위해 WiredTiger를 인수하고 MongoDB 서버의 스토리지 엔진으로 내장한 것입니다.

WiredTiger 스토리지 엔진은 내부적인 잠금 경합 최소화(Lock-free Algorithm)를 위해 "하자드 포인터(Hazard-Pointer)"나 "스킵 리스트(Skip-List)"와 같은 많은 신기술을 채택하고 있으며, 최신 RDBMS 서버들이 가지고 있는 MVCC(잠금 없는 데이터 읽기)와 데이터 파일 압축, 그리고 암호화 기능들을 모두 갖추고 있습니다. MongoDB 서버는 WiredTiger 스토리지 엔진을 내장함으로써 단번에 상용 RDBMS가 가지고 있는 기능들을 모두 지원합니다.



### 🚀 WiredTiger 스토리지 엔진 설정
---
WiredTiger 스토리지 엔진 설정과 관련된 파라미터는 아래와 같습니다.

{% include codeHeader.html name="/etc/mongod.conf" %}
```json
작성필요
```

#### 파라미터 설명

syncPeriodSecs: MongoDB의 대부분 스토리지 엔진은 DIRECT-IO를 사용하지 않기 때문에, 데이터 쓰기는 일반적으로 운영체제의 캐시 메모리에 머물러 있을 가능성이 큽니다. 따라서 MongoDB 서버는 주기적으로 캐시의 더티 페이지(디스크로 기록되지 않은 데이터)를 디스크로 플러시(동기화)하는데, syncPeriodSecs는 이러한 동기화 주기를 결정합니다. 일반적으로 저널 로그를 활성화한 경우에는 데이터 파일이 손실되더라도 자동 복구가 가능하므로, 이 설정은 상대적으로 중요도가 낮습니다.  
<br/>
journal: MongoDB 서버의 저널 로그는 데이터 변경 내역을 기록하여 복구에 사용됩니다. journalenabled를 false로 설정하면 저널 로그를 생성하지 않아 복구 기능이 제한됩니다. journal.commitIntervalMs 옵션은 저널 로그를 디스크에 강제로 동기화하는 주기를 설정합니다. MongoDB는 트랜잭션 단위로 저널 로그를 동기화하지 않고, commitIntervalMs에 설정된 시간마다 일괄적으로 동기화합니다.  
<br/>
engine: MongoDB는 일반적으로 하나의 인스턴스에서 단일 스토리지 엔진을 사용합니다. MongoDB 3.0에서는 예외적으로MMAPv1과 WiredTiger를 동시에 사용할 수 있었지만, 이는 지원 중단된 기능입니다. storage.engine 항목은 기본 스토리지 엔진을 지정하는데, WiredTiger가 가장 일반적으로 사용됩니다. wiredTiger 섹션에서는 engineConfig, collectionConfig,indexConfig 등을 통해 다양한 설정을 할 수 있습니다.  
<br/>
engineConfig.cacheSizeGB: WiredTiger 스토리지 엔진의 공유 캐시 크기를 설정합니다. 공유 캐시는 자주 사용되는 데이터를 메모리에 저장하여 디스크 I/O를 줄여 성능을 향상시킵니다. 일반적으로 서버 메모리의 50~60%를 할당하는 것이 좋습니다.  
<br/>
collectionConfig.blockCompressor: WiredTiger는 데이터 파일을 압축하여 디스크 공간을 절약할 수 있습니다. Zlib,snappy 등의 압축 알고리즘을 선택할 수 있으며, "none"으로 설정하면 압축을 사용하지 않습니다.  
<br/>
indexConfig.prefixCompression: WiredTiger의 인덱스는 접두사 압축을 지원하여 인덱스 크기를 줄일 수 있습니다.
<br/>


### 🚀 WiredTiger의 내부 작동 방식
---
WiredTiger 스토리지 엔진은 내장된 공유 캐시(버퍼 풀)를 가지고 있습니다. WiredTiger의 내장된 공유 캐시는 디스크의 인덱스나 데이터 파일을 메모리에 캐시하여 빠르게 쿼리를 처리할 뿐만 아니라, 데이터의 변경을 모아서 한 번에 디스크로 기록하는 체크포인트 기능도 가지고 있습니다. 

![WiredTiger 내부 작동 방식](https://github.com/user-attachments/assets/3cf9d6e7-bddf-49ae-88e0-4f0f6e5059db "WiredTiger 내부 작동 방식")

위의 그림에서 점선으로 된 화살표는 데이터 변경으로 발생한 더티 페이지를 디스크로 기록하는 과정을 보여주고 있으며, 실선으로 된 화살표는 디스크의 데이터 파일이나 인덱스를 공유 캐시로 읽어 들이는 과정을 나타냅니다.

사용자가 쿼리를 실행하면 WiredTiger 스토리지 엔진은 블록 매니저(Block Manager)를 통해 필요한 데이터 블록을 디스크에서 읽어서 공유 캐시에 적재하고 쿼리를 처리합니다. 만약 사용자가 데이터를 변경하면 WiredTiger 스토리지 엔진은 트랜잭션을 시작하고 커서를 이용해 원하는 도큐먼트의 내용을 변경합니다. 도큐먼트의 변경 내용은 먼저 공유 캐시에 적용되며, WiredTiger 스토리지 엔진은 변경된 데이터가 디스크에 기록될 때까지 기다리지 않고 변경 내용을 저널 로그에 기록한 후 사용자에게 작업 처리 결과를 반환합니다. WriteConcern 옵션에 따라 달라질 수 있지만, 기본적으로 사용자에게 작업 처리 결과를 반환하는 시점은 저널 로그의 기록이 완료되는 시점입니다. 이렇게 공유 캐시가 어느 정도 쌓이면, WiredTiger 스토리지 엔진은 체크포인트를 발생시켜 공유 캐시의 더티 페이지를 모아 디스크에 기록합니다. 이때, 메모리의 더티 페이지는 디스크에 기록되기 전에 가공 작업(원본 레코드와 변경된 정보의 병합)을 거치게 되며, 이 작업은 WiredTiger 스토리지 엔진의 리컨실리에이션(Reconciliation) 모듈이 담당합니다.  

사용자 요청 쿼리가 실행되면 블록 매니저는 디스크의 새로운 데이터 페이지들을 계속해서 공유 캐시로 읽어 들여야 합니다. 하지만, WiredTiger 스토리지 엔진의 공유 캐시는 사용자가 설정한 크기의 메모리 범위 내에서 처리되어야 합니다. 만약 공유 캐시에 더 이상 데이터 페이지를 읽어 들일 공간이 없으면, 사용자의 쿼리를 처리할 수 없게 되므로 WiredTiger의 이빅션(Eviction) 모듈은 공유 캐시가 적절한 메모리 사용량을 유지하도록 공유 캐시에서 자주 사용되지 않는 데이터 페이지들을 제거하는 작업을 수행합니다. 만약 제거해야 할 데이터 페이지가 더티 페이지라면, 리컨실리에이션 모듈을 통해 디스크에 데이터를 기록한 후 공유 캐시에서 제거합니다. 이 과정 중 어느 한 곳에서라도 처리가 느려지거나 문제가 생기면, 쿼리 처리 속도가 느려질 수 있습니다.

WiredTiger 스토리지 엔진의 데이터 블록(페이지)은 모두 가변 크기입니다. 오라클 RDBMS나 MySQL 서버와 같은 RDBMS 서버는 모두 고정된 크기의 데이터 블록을 사용하지만, WiredTiger 스토리지 엔진의 블록 크기는 상한선이 있을 뿐, 저장되는 실제 데이터 블록의 크기는 고정되어 있지 않습니다. 고정 크기와 가변 크기 데이터 블록 규칙은 각각 장단점이 있지만, 고정 크기의 경우 데이터 파일의 압축 기능을 구현하기가 어렵습니다. 예를 들어, 16KB 데이터 페이지를 압축하면 압축된 결과의 크기는 데이터의 내용에 따라 가변적일 수밖에 없는데, 이 가변적인 결과를 어떤 고정된 크기의 데이터 블록에 저장해야 하므로 오히려 압축 효율이 떨어질 가능성이 큽니다. 그래서 가변 크기의 블록을 사용하는 WiredTiger 스토리지 엔진에서는 데이터 파일의 압축이 선택 사항이 아니라 기본적으로 자주 사용되는 옵션입니다. 하지만 가변 크기의 블록을 사용하면, 변경된 데이터 블록을 데이터 파일에 다시 기록할 때 적절히 빈 공간을 찾아서 저장하는 알고리즘이 중요합니다.

WiredTiger 스토리지 엔진의 블록 매니저(Block Manager)는 변경된 데이터 블록을 기록할 때, 프래그멘테이션을 최소화하면서 기록되는 데이터 블록의 크기에 최적인 위치를 찾아서 저장하는 역할을 담당합니다. 또한, 블록 매니저는 데이터 블록의 압축과 암호화 등 응용 프로그램에 투명하게 작동하는 기능도 모두 내장하고 있습니다.

WiredTiger 스토리지 엔진은 다른 DBMS와 동일하게 B-Tree 구조의 데이터 파일과 서버 크래시(비정상 종료)로부터 데이터를 복구하기 위한 저널 로그(WAL, Write Ahead Log)를 가지고 있습니다. WiredTiger의 저널 로그는 데이터 디렉터리 하위에 있는 'journal'이라는 디렉터리에 저장되며, 다른 RDBMS의 리두 로그(WAL)처럼 로테이션 방식으로 로그 파일의 로그 슬롯이 재활용되는 방식이 아니라, 새로운 로그 파일이 계속 생성됩니다. 그리고 체크포인트 시점 이전의 저널 로그는 더 이상 필요하지 않으므로, 체크포인트 이후 시점의 저널 로그만 남기고 이전 저널 로그는 자동으로 삭제됩니다.  

일반적으로 WiredTiger 스토리지 엔진은 미리 3~10개 정도의 로그 파일을 만들어 두고, 기존 저널 로그 파일(WiredTigerLog.000000N)을 다 사용하면 미리 만들어 둔 로그 파일(WiredTigerPreplog.000000N)의 이름을 WiredTigerLog.000000N으로 변경하여 트랜잭션 로그를 기록합니다. WiredTiger 스토리지 엔진의 저널 로그를 설정하는 여러 가지 옵션이 있으며, MongoDB 설정 파일을 이용해 저널 로그를 활성화할지 비활성화할지를 설정할 수 있습니다.

- 저널로그 활성화(mongod.conf)
```json
storage:
  journal:
    enabled: true
```

### 🚀 공유 캐시
---
WiredTiger 스토리지 엔진에서 사용자의 쿼리는 공유 캐시를 거치지 않고 처리할 수 없으며, 때로는 하나의 쿼리를 처리하기 위해 수천에서 수만 번 공유 캐시의 데이터 페이지를 참조해야 할 수도 있습니다. 그래서 공유 캐시의 최적화는 MongoDB의 처리 성능에 있어서 매우 중요한 역할을 담당합니다. WiredTiger 스토리지 엔진의 처리가 원활하지 않은 경우, WiredTiger의 공유 캐시 사용량 그래프에 변화가 나타나는 경우가 많습니다. 물론 그렇지 않은 경우라도 WiredTiger 공유 캐시의 사용률은 중요한 모니터링 포인트입니다. MongoDB 3.2 버전에서 내장된 WiredTiger 스토리지 엔진의 공유 캐시 크기는 장착된 메모리의 60% - 1GB입니다.

공유 캐시는 MongoDB 서버를 재시작하지 않고도 크기를 조정할 수 있습니다. 하지만 공유 캐시의 크기를 조정하는 작업은 WiredTiger 스토리지 엔진의 많은 내부 동시 처리 작업들을 멈추고 크기를 변경하게 되므로, 쿼리 처리량이나 부하가 높을 때에는 주의가 필요합니다. 특히 공유 캐시의 크기를 줄이는 작업은 테스트 후 사용량이 낮은 시점을 선택해서 실행하는 것이 좋습니다.

WiredTiger 스토리지 엔진의 공유 캐시에서 메모리에 적재된 페이지를 찾아가는 과정은 별도의 매핑 과정 없이 메모리 주소(C/C++ 포인터)를 이용해 바로 검색할 수 있기 때문에 매핑 테이블의 경합이나 오버헤드가 없습니다.  
일반적인 RDBMS에서는 하나의 데이터 페이지 내에 저장된 레코드들의 인덱스를 별도로 관리합니다. 이는 하나의 데이터 페이지에 저장된 수백 건의 레코드를 처음부터 끝까지 스캔하지 않기 위해 필요한데, WiredTiger 스토리지 엔진은 디스크에 저장되는 데이터 페이지의 레코드 인덱스를 별도로 관리하지 않고 저장합니다. 그리고 데이터 페이지를 공유 캐시 메모리에 적재할 때 레코드 인덱스를 새롭게 생성하여 메모리에 적재하는 다소 여러 가지 변환 과정을 거치므로 데이터 페이지를 디스크에서 공유 캐시로 읽어들이는 과정이 기존 RDBMS보다는 느리게 처리됩니다. 하지만 한 번 공유 캐시 메모리에 적재된 데이터 페이지에서 필요한 레코드를 검색하고 변경하는 작업은 기존의 RDBMS보다 훨씬 빠르고 효율적으로 작동합니다.

짧은 시간에 수많은 쿼리를 처리해야 하는 OLTP(On-Line Transaction Processing) 시스템에서는 많은 쿼리가 공유 캐시에 있는 하나의 데이터 페이지를 동시에 참조하기 위해 경합하는 경우가 많으므로, 공유 캐시의 객체에 대한 잠금 경합이 성능에 많은 영향을 미치게 됩니다. WiredTiger 스토리지 엔진은 공유 캐시의 잠금 경합(Mutex Contention)을 최소화하기 위해 Lock-Free 알고리즘을 채택하고 있습니다. 일반적으로 Lock-Free 알고리즘은 잠금을 전혀 사용하지 않는 시스템을 의미하는 것이 아니라, 잠금 경합을 최소화하는 알고리즘을 의미합니다. WiredTiger 스토리지 엔진에서는 대표적으로 "하자드 포인터"와 "스킵 리스트" 자료 구조를 활용하여 Lock-Free 개념을 구현하고 있습니다.

### 🚀 하자드 포인터
---

### 🚀 스킵 리스트
---

### 🚀 캐시 이빅션
---

### 🚀 체크포인트
---

### 🚀 MVCC
---

### 🚀 하자드 포인터
---

### 🚀 데이터 블록
---

### 🚀 하자드 포인터
---

### 🚀 운영체제 캐시
---

### 🚀 압축
---


{% assign posts = site.categories.Mongodb %}
{% for post in posts %} {% include archive-single2.html type=page.entries_layout %} {% endfor %}