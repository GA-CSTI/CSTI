---
layout: post
title:  "안드로이드 스튜디오"
---
# 2024학년도 2학기

Android Studio Missing Keymap - Cannot find keymap "Windows Proper Redo"


안드로이드
- 안드로이드는 공개(오픈소스) 운영체제인 리눅스를 기반으로 함
- 안드로이드 앱 개발 언어로 JAVA or Kotlin

안드로이드 구조
- 리눅스 커널
    - 하드웨어의 운영과 관련된 저수준(low-level)의 관ㄹ 기능 포함
    - 주로 오디오, 디스플레이, 카메라 등을 제어 및 전원 관리
-하드웨어 추상화 레이어 ( HAL, Hardware Abstraction Layer ) 
    - 상위 자바 API 프레임워크에서 하드웨어의 표준 인터페이스 제공
    - 하드웨어의 상세한정보를 몰라도 이용 가능
-안드로이드 런타임 ( ART, Android RunTime )
    - DEX로 빌드 된 안드로이드 앱을 해석해서 실행하는 주체
-네이티브 C/C++ 라이브러리 ( NDK, Native Development Kit )
    - ART or HAL 등의 안드로이드 핵심 구성요소가 이용하는 C/C++ 라이브러리 
-자바 API 프레임워크
    - 앱을 개발할 때 사용하는 자바 API
    - 안드로이드의 전체 기능을 API를 통해 접근 가능


컴포넌트
- 앱을 구성하는 단위
- 안드로이드에서 컴포넌트는 클래스로 개발

컴포넌트 종류 4가지
- 액티비티 : 사용자와의 상호작용을 위한 화면을 구성, 일반적으로 UI를 갖는 하나의 화면을 출력
- 서비스 : 사용자에게 보이지 않는 영역의 작업을 처리, 화면 출력 없이 백그라운드에서 동작
- 콘텐츠 프로바이더 : 자신의 데이터를 외부에 공개하기 위해 생성
- 브로드캐스트 리시버 : 시스템 이벤트가 발생했을 때 실행, 앱에서 특정 이벤트 메시지를 수신하여 상황에 맞게 동작 수행

컴포넌트 클래스 vs 일반 클래스
- 컴포넌트 클래스 : 안드로이드 시스템에서 생명주기 관리
    - 안드로이드 시스템이 생성하고 필요 없는 순간 시스테이 소멸시킴
- 일반 클래스 : 개발자 코드에서 생명 주기 관리
    - 개발자가 코드에서 new 연산자로 생성 및 null 대입하여 소멸 가능

컴포넌트의 결합 방법
- 컴포넌트는 상호 결합하지 않은 상태이며 독립적으로 존재
- 인텐트(Intent) : 다른 컴포넌트를 실행하기 위해 시스템에 전달하는 메시지, 컴포넌트 간 작업 수행을 위한 정보를 전달

컴포넌트의 실행
- 컴포넌트는 앱 안에서 독립된 실행 단위 ; 서로 종속 X,  코드결합이 발생X
- 안드로이드 시스테에 의뢰하여 간접적이고 독립적으로 실행

안드로이드는 최대한 리소스 외부화하려고 함
- 코드에서 정적(static) 값 분리 = 리소스화

프로젝트 트리
- AndroidManifest : 앱 환경 설정
- MainAtivity : 메인 엑티비티(화면), 화면 출력 컴포넌트
-  activity_main : 레이아웃 xml
- build gradle (Project), build gradle(Module) : 빌드 설정



=================================================

3주차, 코틀린 시작하기

코틀린의 이점
- 표현력과 간결함  : 세미콜론 생략 가능, 준비 코드( 생성자, getter, setter ) 등을 묵시적으로 제공
- 안전한 코드 : 널 안전성 지원, 변수를 널 허용(nullable)과 널 불허용(non-nullable)로 구분해서 선언
- 상호 운용성 : 자바와 코틀린 모두 JVM기반 언어, 코틀린언어에서 자바 클래스 이용

코틀린 코딩 컨벤션 
- 개발자 간 원활한 협업을 위한 코드 작성 규칙
- 카멜 케이스(변수명과 함수명) : 처음은 소문자로 시작, 단어의 첫 글자는 대문자
- 파스칼 케이스(클래스명) : 대문자로 시작, 단어의 첫글자는 대문자
- 스네이크 케이스(리소스 파일명) : 언더바(_) 이용하여 단어를 나눔
- 상수명 : 모두 대문자로 작성 및 단어 사이를 언더바로 나눔

변수 선언
- 이름 앞에 val(value) 혹은 var(variable)을 입력하여 선언
- 이름 뒤에 콜론(:)을 추가해 타입 명시한 후 값을 대임3

var(variable) : 초기값이 할당된 후에도 필요할 때마다 값을 변경할 수 있음
val(value) : 초기값이 할당되면 값을 변경할 수 없음
- 타입이 존재하지 않는 것이 아니라 유추하여 자동으로 지정되는 개념
- 최상위에 선언한 변수 & 클래스의 멤버 변수 : 선언과 동시에 초기값을 할당해야 함
lateinit : 이후 값을 할당할 것임을 명시적으로 선언, var키워드로 선언한 변수에만 사용 가능
               int, Short, Long, Boolean, Double, Float, Byte과 같은 (기초타입객체)에는 사용 불가
lazy : 초기화 미루기, 변수 선언문뒤에 by lazy{ } 형식으로 선언
        val data4 : Int by lazy{ " in lazy ") 10 }


데이터 타입 
- 코틀린의 모든 변수는 객체
- 정수를 다루는 타입인 int는 클래스이며변수에는 null 대입 가능
- 문자열 템플릿 $기호 사용
Any : 최상위 클래스, 모든 타입 가능
Unit : 데이터 형식이 아닌 특수한 상황을(반환문이 없음)을 명시하려는 목적
         Unit만 대입 가능하며, 함수에서 반환 타입을 생략하면 자동으로 적용
Nothing
- Unit 처럼 특수한 상황을 표현, null만 대입 가능하며 결국 null or  예외를 반환
널허용과 불허용
- 변수를 선언할 때 null을 대입할 수 있는 없는지 명확하게 구분
- 타입 뒤에 물음표를 표시하면 널 허용 ( ex)  var data2: Int? = 10 )

함수
- 반환 타입을 선언할 수 있고 생략할 경우 Unit 타입으로 적용
- 함수의 매개변수는 var을 사용할 수 없으며 val이 자동으로 적용

컬렉션 타입

Array : 배열은 Array 클래스로 표현 

var 배열명 = Array<데이터 형식> (개수, {초깃값})  val data1: Array<Int>(3, {0})

선언과 동시에 할당 : arrayof() 함수 이용

val data1 = arrayOf<Int>(10, 20, 30)

List : 데이터의 순서가 있으며 중복을 허용함, List는 불변, Mutable은 가변

var list = listOf<Int>(10, 20, 30)

Set: 데이터의 순서가 있으며 중복을 허용함, setof()는 불변, mutableSetOf()는 가변

Map : 키와 값으로 이뤄진 데이터 집합으로 순서가 없고 중복을 허용하지 않음, mapOf()는 불변, mutableMapOf()는 가변

When : 여러가지 경우에 따라서 어떤 작업을 할 것인지 결정 ( switch )
- when(data){  10 -> println("10") else -> println("0") }

=====================================================================

4주차 : 코틀린 객체지향 프로그래밍

객체지향 프로그래밍 ( Object-Oriented Porgramming, OOP) : 클래스를 선언하고 객체를 생성한 후, 객체들 간 상호작용을 통해 로직을 구성하는 프로그래밍 방식

constructor : 생성자 선언 함수 키워드 ex) constructor(name : String){ this. name = name}
- 객체를 생성할 때 new 키워드를 사용하지 않음

클래스 상속
- 자식 (하위, 서브)클래스 B가 부모(상위, 슈퍼) 클래스 A의 내용을 물려 받음
- 부모 클래스는 open 키워드로 만드렁야만 상속해 줄 수 있음
- 부모 클래스에 정의된 멤버를 자식 클래스에서 자기 것 처럼 사용
- 자식 클래스의 생성자에서 반드시 부모 클래스의 생성자를 호출
- 
오버라이딩 : 부모 클래스의 변수나 함수의 내용을 무시하고 새롭게 재정의 하는 것을 의미, 변수 함수 선언 앞에 open 키워드 추가

오브젝트 클래스
- 클래스 이름이 없는 익명 클래스를 만들 목적으로 사용
- object 키워드 사용하며 선언과 동시에 객체를 생성하게 됨

==================================================================

5주차 :코트린의 유용한 기법

람다 함수: 함수를 이름 없는 익명 함수로 표현하는 기법
- Fun 키워드를 사용하지 않고 중괄호{ } 안에 모든 내용을 표현
- 화살표(->)를 기준으로 매개변수를 왼쪽으로, 함수 본문을 오른쪽으로 작성
- 본문마지막 표현식을 반환함
  - val sum = {no1 : int -> no1+ 10}
- 매개 변수가 없는 경우 화살표 왼쪽과 화살표 생략 가능
  - {println("fun call")}

고차 함수 : 함수를 매개변수로 전달 받거나 반환하는 함수

널(null) : 객체가 선언되었지만 초기화되지 않은 상태
- 널 상태의객체를 이용하면너포이너 예외 발생
- 널 안전성이란 널포인트 예외가 발생하지 않도록 코드를 작성하는 기능
- 널 허용 연산자 ; 변수선언 시 널 허용과 널 불허로 구분, ? 연산자 추가
- 엘비스 연산자 " ?: " 변수가 널일때 값을 대입하거나구문을 실행하는 경우 연산자 오른쪽 값이 반환
- 예외발생 연산자 : 널포인트 예외를 발생시키고 싶을때 !! 연산자 이용


===============================================================

6주차 : 뷰를 이용한 화면 구성

액티비티-뷰 구조 : 액티비티 컴포넌트로 화면을 출력, 화면에 내용을 표시하기 위해 뷰(view) 클래스 사용

안드로이드에서 모든 뷰는 최상위 클래스 View를 상속 받음

ViewGroup : 화면 출력을 목적으로 하지 않고 자체 UI가 없음

레이아웃 중첩 : 뷰의 계층 구조는 레이아웃 객체를 중첩해서 구성하기도 함
- LinearLayout

뷰 클래스의 XML 속성 - ' @/id'를 사용
 - 레이아웃 XML의 뷰를 코드에서 사용하기 위한 속성
 - 보통 화면 출력 이후 이벤트에 의하여 동작이 필요한 경우 id를 지정
 - 수치 : 단위는 px, dp를 사용
 - wrap_content : 콘텐츠(내용)가 하면에 맞춰서 출력될 수 있도록 적절한 크기로 지정
 - match_parant : 콘텐츠와 관계없이 자신의 부모 크기에 꽉 차도록 지정
 - 뷰의 색상을 지정하는 속성 : backgroun: 배경을 대체 , backgroundTint : 기존 배경 모양을 유지하며 덧 씌우는 방식
 - margin : 뷰와 뷰 사이의 간견
 - padding : 뷰의 테두리와 콘텐츠 사이의 간격
 - visivility : 뷰가 화면에 출력되어야 하는지 설정 ( visivle -> 출력, invisible -> 자리만 유지, gone -> 삭제
 - autoLink : 출력할 문자열을 분석해 특정 형태에 자동 링크 추가 : web, phone, email 등을 사용


뷰 바인딩 : 레이아웃 XML 파일에 선언한 뷰 객체를 코드에서 쉽게 이용하는 방법
              - 액티비티에서 findViewByID()함수 사용 안해도 돈다 한번에 쫙 받아오기 가능

================================================================

7주차 : 뷰를 배치하는 레이아웃

레이아웃 클래스 : 화면을 독자적으로 출력하지 않고 다른 뷰 객체를 포함하는 그릇 역할

레이아웃 클래스도 뷰이므로 다른 레이아웃에 포함하여 중첩 시킬 수 있음
  
LinearLayout
- 뷰를 레이아웃의 왼쪽 위부터 오른쪽(가로) or 아래쪽(세로) 방향으로 배치
- orientation 속성에 horizontal or vertical 값으로 방향 지정
- 추가한 뷰가 화면에서 벗어날 경우 자동으로 줄바꿈하지 않음 ( 아예 안보여줌 )
- layout_weight : 여백을 뷰로 채울수 있도록 만드는 속성 가중치로 여백을 채움
                            뷰의 크기를 0dp로 하고 속성 값만 설정하기도 함
- gravity : 자신을 기준으로 포함된 콘텐츠(뷰, 텍스트 등) 어떻게 정렬할 것인지 지정
- layout_gravity : 부모를 기준으로 자신을 어떻게 정렬할 것인지
- baselineAligned : 크기가 다른 뷰들을 정렬하기 위한 속성

RelativeLayout
- 상대 뷰의 위치를 기준으로 배치, 특정 뷰를 기준으로 방향 지정
- "@+id/기준 뷰의 아이디"


GridLayout
- 뷰를 표 형태로 배치
- 유일하게 길이 설정은 안해도 됨 ( 초기값이 있음)
- rowCount : 세로로 나열할 뷰 개수
- columnCount : 가로로 나열할 뷰 개수
- 특정한 뷰의 위치를 조정하기 위한 속성 : layout_row / layout_column
- 행 or 열을 병합하기 위한 속성 : layout_rowSpan, layout-columnSpan
- 확장된 행 or 열에 뷰를 가득 채우기 : fill, fill_vertial, fill_horizontal

FrameLayout
- 화면을 겹칠떄 사용, 왼쪽 상단부터 겹쳐서 배치
- 일반적으로 뷰를 표시하는 visibility 속성과 함께 사용



------------------------------------------------------------------------------------------------------

intent로 액티비티가 실행

startActivity() 함수가 인텐트를 시스템에 전달
intent 객체를 생성하여 startActivity()의 인자로 전달
- intent.putExtra("data", "10") = 커포넌트에서 데이터를 추가하기 위해 호출 하는함수
- intent.getXXXExtra("data1") = XXX타입의 데이터를 가져오기위해 호출 하는 함수

사후처리가 필요한 경우

startActivityForResult()함수로 액티비티 시작

실행된 액티비티가 끝나기 전 돌려줄 인텐트를 생성하고 setRsult()함수로돌려줌

intent.putExtra("resultData", "world")

setResult(RESULT_OK, intent)

finish()

bundle 객체에 복원이 필요한 데이터를저장

브로드캐스트 리시버

시스템 이벤가(전화수신, 배터리 부족) 발생했을 때 실행
